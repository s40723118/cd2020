<h1>About</h1>
<p>個人倉儲: <a href="https://github.com/s40723118/cd2020">https://github.com/s40723118/cd2020</a></p>
<p>群組網站:<a href="https://s40723114.github.io/cd2020-ag1/content/index.html">https://s40723114.github.io/cd2020-ag1/content/index.html</a></p>
<p>群組倉儲:<a href="https://github.com/s40723118/cd2020-ag1">https://github.com/s40723118/cd2020-ag1</a></p>
<h1>Assignment1</h1>
<h2>python 更新</h2>
<p><em><strong>python 3.8.2</strong></em></p>
<p><img alt="" height="405" src="/images/2020-04-06_21-18-59.png" width="720"/></p>
<h2>了解四輪機器人</h2>
<p>翻譯的網址:<a href="https://www.coppeliarobotics.com/helpFiles/index.html">https://www.coppeliarobotics.com/helpFiles/index.html</a></p>
<p>翻譯</p>
<p>路徑位置和長度計算方法<span>(Path position and length calculation methods)</span></p>
<p>沿著路徑對象，可以定義固有位置。該位置（也稱為路徑位置）與路徑對象的位置不同。雖然路徑對象的位置是路徑對象原點的位置（在選擇路徑時顯示為白色線框立方體），但是路徑位置或固有路徑位置是沿路徑的位置值</p>
<p>路徑的<span>Bezier</span>點可以是不同的，也可以是重合的：想像一個焊接機器人，其末端執行器是焊接設備的尖端；在兩個連續的<span>Bezier</span>點之間，末端執行器可以：</p>
<p>在不改變方向的情況下執行平移（即沿著直線）（兩個<span>Bezier</span>點是不同的，但方向相同）。</p>
<p>執行平移並更改方向（兩個<span>Bezier</span>點是不同的，並且方向不同）。</p>
<p>在不改變位置的情況下執行旋轉（即更改方向）（兩個<span>Bezier</span>點重合但方向不同）。</p>
<p>此外，在某些情況下，我們希望焊炬遵循預定的路徑，在某個特定位置暫停（例如，處理較大的焊接點），然後沿該路徑繼續前進。為了正確處理上述<span>3</span>種情況和特殊的暫停情況，重要的是能夠唯一地識別沿路徑（即路徑位置<span>*</span>）的任何位置<span>*</span>（廣義上的位置）以及路徑長度<span>*</span>（從更廣泛的意義上講是長度）。為此，用戶可以選擇幾種位置計算方法：<span> </span></p>
<p>路徑位置<span>*</span>被描述為沿路徑的累積線性變化。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="/images/公式1.jpg" width="92"/></p>
<p>路徑位置<span>*</span>被描述為沿路徑的累積角度<span>**</span>變化。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="/images/公式2.jpg" width="107"/></p>
<p>路徑位置<span>*</span>被描述為沿路徑的累積（線性變化<span>+</span>角度<span>**</span>變化）。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="/images/公式3.jpg" width="139"/></p>
<p>路徑位置<span>*</span>被描述為沿路徑的累積最大值（線性變化，角度<span>**</span>變化）。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="/images/公式4.jpg" width="169"/></p>
<p>路徑位置<span>*</span>被描述為沿路徑的累積（線性變化，如果不為零，否則為角度<span>**</span>）。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="/images/公式5.jpg" width="328"/></p>
<p>路徑位置<span>*</span>被描述為沿路徑的累積（角度<span>**</span>變化，如果不為零，否則為線性變化）。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="/images/公式6.jpg" width="347"/></p>
<p>路徑位置<span>*</span>被描述為沿路徑的（線性變化，角度<span>**</span>變化）的累積歐幾里德距離。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="/images/公式7.jpg" width="145"/></p>
<p>其中Δ<span>l</span>和Δα分別是兩個連續的<span>Bezier</span>點之間的線性和角度變化。角度<span>**</span>變化是規則角度變化乘以角度係數<span>c</span>。<span> c</span>稱為角度到線性的轉換係數，並且可以將角度值和線性值組合在一起。這意味著沿路徑的位置<span>*</span>或路徑長度<span>*</span>始終以線性單位（例如米）給出，而與上面選擇的位置計算方法無關。</p>
<p><span> </span>默認情況下，紅色標記的項為零。該術語可以看作是<span>Bezier</span>點（或路徑控制點）的虛擬距離或第四坐標（即每個<span>Bezier</span>點將由方向和位置（<span>x</span>，<span>y</span>，<span>z</span>，<span>w</span>）定義，其中<span>w</span>是第四坐標）。這對於沿路徑歸檔暫停點很有用。是兩個連續的<span>Bezier</span>點之間的虛擬距離變化。<span> d</span>是虛擬距離變化的比例因子（例如，如果<span>d</span>加倍，則所有暫停點的暫停持續時間將是兩倍）。為簡化起見，在以下內容中我們將不再提及該術語並將其設為零。</p>
<p>以下示例闡明了位置和長度計算概念：</p>
<p><img alt="" height="256" src="/images/計算1.jpg" width="600"/></p>
<p><img alt="" height="220" src="/images/計算2.jpg" width="450"/></p>
<p><img alt="" height="205" src="/images/計算3.jpg" width="600"/></p>
<p><img alt="" height="192" src="/images/計算4.jpg" width="450"/></p>
<p>要歸檔沿路徑的特定點處的運動暫停，請執行以下操作：創建3個相同的路徑控制點（位置和方向完全重合），並為中間控制點指定一個虛擬距離值，該值不得為零。在下面的示例中，在3個重合點的虛擬距離為2（在第一和中間重合控制點之間為1，在中間和第三重合控制點之間為1）。如果某個對像以每秒1米的速度沿路徑行進，則它將在重合的控制點處記錄2秒的暫停</p>
<p><img alt="" height="213" src="/images/計算5.jpg" width="285"/></p>
<p></p>
<p>沿路徑運動<span>(Movement along a Path)</span></p>
<p>當前固有路徑位置在路徑上顯示為紅色球形（如果啟用了路徑位置顯示）。在模擬過程中，可以隨時使用<span>sim.setPathPosition</span>來控制球沿路徑的位置。確保了解如何計算路徑位置或路徑長度。</p>
<p>要實際使對象沿路徑移動，首先需要將對象附加到虛擬對象，然後分配虛擬對像以遵循路徑位置（帶有可選的偏移量）。</p>
<p>導入和導出路徑<span>(Importing and exporting paths)</span></p>
<p>路徑導入<span>/</span>導出功能可在<span>CSV</span>文件（逗號分隔值）上運行，該<span>CSV</span>文件可以用簡單的文本編輯器創建或讀取，但也可以輕鬆地導入<span>/</span>導出到<span>Microsoft Excel</span>等應用程序中。</p>
<p>導入路徑</p>
<p><span>CoppeliaSim</span>的導入功能（<span>[</span>菜單欄<span>-&gt;</span>文件<span>-&gt;</span>導入<span>-&gt; CSV</span>的路徑<span>...]</span>）逐行讀取值，其中每行對應一個控制點。每行應採用以下格式設置：<span> </span></p>
<p><span>x</span>，<span>y</span>，<span>z</span>，<span>alpha</span>，<span>beta</span>，<span>gamma</span>，<span>relativeVelocity</span>，<span>BezierPointCount</span>，<span>interpolationFactor1</span>，<span>interpolationFactor2</span>，</p>
<p><span>virtualDistance</span>，<span>auxiliaryFlags</span>，<span>auxiliaryChannel1</span>，<span>auxiliaryChannel2</span>，<span>auxiliaryChannel3</span>，<span>auxiliaryChannel4</span></p>
<p>其中內容相對應的意思：</p>
<p><span> </span>（<span>x</span>，<span>y</span>，<span>z</span>）表示控制點在<span>METERS</span>中的位置</p>
<p>（α，β，γ）表示控制點的方向，以度數表示為歐拉角。默認值為（<span>0,0,0</span>）。</p>
<p>相對速度已棄用。設為<span>1.0</span></p>
<p><span>BezierPointCount</span>是控制點所需的<span>Bezier</span>點數。默認值為<span>1</span>。</p>
<p><span>InterpolationFactor1</span>和<span>InterpolationFactor2</span>是在路徑控制點和<span>Bezier</span>點部分中描述的插值因子。默認值為<span>0.5</span></p>
<p><span>VirtualDistance</span>：虛擬距離值，添加到該控制點位置的路徑長度上，另請參見路徑位置或路徑長度計算方法。默認值為<span>0.0</span></p>
<p>輔助標誌：可以用於各種目的的標誌，可以通過<span>sim.getDataOnPath</span>函數進行查詢。默認值為<span>0</span>。</p>
<p>輔助通道<span>1-4</span>：可以用於各種目的的值，可以通過<span>sim.getDataOnPath</span>函數進行查詢。默認值為<span>0.0</span></p>
<p>除了前三個值（控制點位置坐標）外，所有其他值都可以省略，在這種情況下，將應用默認值。</p>
<p>導出路徑</p>
<p>通過選擇路徑，然後單擊<span>[</span>菜單欄<span>-&gt;</span>文件<span>-&gt;</span>導出<span>-&gt;</span>選定路徑為<span>CSV ...]</span>，可以導出路徑的控制點。在這種情況下，導出格式與前面描述的路徑導入格式相同。</p>
<p>也可以通過選擇路徑，然後單擊<span>[</span>菜單欄<span>-&gt;</span>文件<span>-&gt;</span>導出<span>-&gt;</span>所選路徑的<span>Bezier</span>曲線為<span>CSV ...]</span>來導出路徑的<span>Bezier</span>點。在這種情況下，創建的文件（導出的文件）中的每一行都對應一個<span>Bezier</span>點，並包含以下值：</p>
<p><span> </span><span>x</span>，<span>y</span>，<span>z</span>，<span>alpha</span>，<span>beta</span>，<span>gamma</span>，相對速度，虛擬距離，輔助標記，輔助通道<span>1</span>，輔助通道<span>2</span>，assistantChannel3，auxiliaryChannel4</p>
<p>路徑編輯模式<span>(Path edit mode)</span></p>
<p>初步說明：路徑編輯模式是一種方便且功能齊全的編輯路徑對象的方法。但是，可以在不進入用於最小化路徑修改的路徑編輯模式的情況下移動和擦除單個路徑點（選擇單個路徑點時，請確保沒有選擇除路徑之外的其他對象）。</p>
<p>可以通過單擊相應的工具欄按鈕來訪問路徑編輯模式：</p>
<p><span><img alt="" height="37" src="/images/路徑編輯一.jpg" width="38"/> </span></p>
<p><span>[</span>路徑編輯模式工具欄按鈕<span>]</span></p>
<p><span> </span>上面的工具欄按鈕僅在選擇路徑後才有效。在路徑編輯模式下，窗口中通常顯示場景層次結構的部分用於將路徑控制點顯示為列表。可以使用鼠標選擇列表中的項目，就像在層次結構窗口中的對像一樣。</p>
<p><img alt="" height="478" src="/images/路徑編輯二.jpg" width="600"/></p>
<p><span>[</span>路徑編輯模式<span>]</span></p>
<p><span> </span>現在可以像常規對像一樣選擇單個控制點。最後選擇的控制點以白色顯示，其他選擇的控制點以黃色顯示，未選擇的控制點以藍色顯示。以類似的方式，可以使用鼠標直接平移控制點，方法是使用工具欄的對象<span>/</span>項目平移工具欄按鈕在與視圖方向垂直的平面中平移所選的控制點：</p>
<p><span><img alt="" height="37" src="/images/路徑編輯三.jpg" width="38"/> </span></p>
<p><span>[</span>對象<span>/</span>項目翻譯工具欄按鈕<span>]</span></p>
<p><span> </span>在路徑編輯模式下，將顯示路徑編輯模式對話框：</p>
<p><span> <img alt="" height="478" src="/images/路徑編輯四.jpg" width="396"/></span><span> </span></p>
<p><span>[</span>控制點屬性對話框<span>]</span></p>
<p><span> </span>路徑已關閉：如果選中，則路徑的最後一個控制點將鏈接到其第一個控制點，以關閉路徑並使其循環運行。閉合路徑至少需要<span>3</span>個控制點。</p>
<p>路徑是平坦的：如果選中，則所有控制點（以及隨後的所有<span>Bezier</span>點）都將約束到路徑對象的本地參考系的<span>z = 0</span>平面。</p>
<p>自動定向：如果啟用，則將自動計算所有控制點和貝塞爾曲線點的定向，以使該點的<span>z</span>軸沿著路徑，其<span>y</span>軸指向其曲率向外（如果啟用了<span>x up</span>，則<span>y -</span>軸沒有特別限制）。如果禁用，則用戶確定控制點的方向，貝塞爾曲線點的方向將從路徑的控制點的方向內插。</p>
<p>保持<span>x</span>向上：如果選中，則自動定向功能將使每個<span>Bezier</span>點的<span>z</span>軸沿路徑對齊，並使其<span>x</span>軸沿路徑對象的<span>z</span>軸指向。</p>
<p>清除選擇：清除控制點的選擇。</p>
<p>反轉選擇：反轉控制點的選擇狀態。</p>
<p>製作虛擬對象：在選擇控制點的位置生成虛擬對象。</p>
<p>貝塞爾曲線插值因子<span>1/2</span>：有關詳細信息，請參見控制點和貝塞爾曲線部分。</p>
<p>貝塞爾曲線點數：有關詳細信息，請參見控制點和貝塞爾曲線部分。</p>
<p>虛擬距離：有關詳細信息，請參見關於沿路徑運動的部分。</p>
<p>輔助標誌：可以用於各種目的的標誌，可以通過<span>sim.getDataOnPath</span>函數進行查詢。</p>
<p>輔助通道<span>1-4</span>：可以用於各種目的的值，可以通過<span>sim.getDataOnPath</span>函數進行查詢。</p>
<p>為了精確定位控制點，請使用坐標和變換對話框。如果要編輯控制點的方向，請確保禁用路徑的“自動方向”選項（默認情況下啟用該選項）。</p>
<p>常規鍵組合（即<span>ctrl-c</span>，<span>ctrl-v</span>，<span>delete</span>和<span>ctrl-x</span>）支持複製<span>/</span>粘貼<span>/</span>刪除<span>/</span>剪切操作。確保主視圖具有焦點，以便按鍵起作用。如果未選擇任何控制點，則黏貼操作會將復制的控制點黏貼到控制點列表的開頭，否則將黏貼到選定的控制點之後（確保不超過一個控制點）。在此階段選擇）。也可以通過彈出菜單或通過<span>[</span>主菜單<span>-&gt;</span>編輯<span>]</span>訪問相同的複制<span>/</span>黏貼<span>/</span>刪除<span>/</span>剪切功能。其他操作包括：</p>
<p>在路徑的開頭插入新的路徑點<span>/</span>選擇後插入新的路徑點：如果未選擇任何控制點，則在路徑的開頭插入新的控制點；否則，在當前選擇之後插入新的控制點（請確保沒有其他內容）在這種情況下，選擇一個控制點）。</p>
<p>從貝塞爾曲線創建新路徑：使用當前路徑的貝塞爾點生成一個新的路徑對象，即新路徑的控制點將為當前路徑的貝塞爾點。</p>
<p>超頻樹<span>(OC trees)</span></p>
<p><span>OC</span>樹是代表空間分區的對象。它由樹形數據結構組成，其中每個節點正好具有八個子代。佔用的葉節點表示為體素。<span> OC</span>樹可用於為形狀或點雲提供簡化的表示，或者可充當佔用網格<span>/</span>空間：</p>
<p><span><img alt="" height="393" src="/images/樹木3.jpg" width="527"/> </span></p>
<p><span>OC</span>樹是可碰撞，可測量和可檢測的對象。這意味著<span>OC</span>樹：</p>
<p>可用於與其他可碰撞對象的碰撞檢測。</p>
<p>可與其他可測量對像一起用於最小距離計算。</p>
<p>可以被接近傳感器檢測到。</p>
<p><span>OC</span>樹可以使用<span>[</span>菜單欄<span>-&gt;</span>添加<span>-&gt; OC</span>樹<span>]</span>添加到場景中，並通過<span>OC</span>樹屬性進行編輯。</p>
<p><span>CoppeliaSim</span>中可用的<span>OC</span>樹計算（即碰撞，距離和接近傳感器計算）也可以通過<span>Coppelia</span>幾何例程作為獨立例程使用。</p>
<p><span> </span><span>OC</span>樹屬性<span>(OC tree properties)</span></p>
<p><span>OC</span>樹屬性是場景對象屬性對話框的一部分，該對話框位於<span>[</span>菜單欄<span>-&gt;</span>工具<span>-&gt;</span>場景對象屬性<span>]</span>。您還可以通過雙擊場景層次結構中的對像圖標或單擊其工具欄按鈕來打開對話框：</p>
<p><span><img alt="" height="37" src="/images/樹木1.jpg" width="38"/> </span></p>
<p><span>[</span>場景對象屬性工具欄按鈕<span>]</span></p>
<p><span> </span>在場景對象屬性對話框中，單擊<span>OC</span>樹按鈕以顯示<span>OC</span>樹對話框（僅當最後選擇的是<span>OC</span>樹時才會顯示<span>OC</span>樹按鈕）。該對話框顯示最後選擇的<span>OC</span>樹的設置和參數：</p>
<p><span><img alt="" height="342" src="/images/樹木2.jpg" width="380"/> </span></p>
<p><span>[OC</span>樹對話框<span>]</span></p>
<p><span> </span>體素大小：<span>OC</span>樹體素的大小。大小越小，用於<span>OC</span>樹數據結構的內存就越大。</p>
<p>插入選定的可見對象：允許基於選定的可見對象插入體素。僅考慮虛擬對象，形狀，超頻樹和點雲。選擇要插入的所有對象，然後最後選擇目標<span>OC</span>樹對象。</p>
<p>減去選定的可見對象：允許基於選定的可見對象刪除體素。僅考慮虛擬對象，形狀，超頻樹和點雲。選擇要插入的所有對象，然後最後選擇目標<span>OC</span>樹對象。</p>
<p>清除<span>OC</span>樹：從<span>OC</span>樹中刪除所有體素。</p>
<p>體素具有隨機顏色：每個體素將具有隨機顏色。</p>
<p>顯示<span>OC</span>樹結構：顯示<span>OC</span>樹數據結構，主要用於調試目的。</p>
<p>顏色是自發光的：體素將以自發光的顏色顯示。</p>
<p>顯示點而不是體素：對於包含大量體素的<span>OC</span>樹，顯示可能會很慢。在這種情況下，您可以顯示像素體素，而不是立方體素。</p>
<p>調整下一次插入的顏色：允許選擇新的顏色，該顏色將用於新的體素插入。<span><br/> <br/> </span></p>
<p>點雲<span>(Point clouds)</span></p>
<p>點雲是充當基於<span>OC</span>樹的點容器的對象：</p>
<p><span> <img alt="" height="416" src="/images/雲3.jpg" width="599"/></span></p>
<p>點雲是可碰撞，可測量和可檢測的對象。這意味著點雲：</p>
<p>可用於與其他基於體積的可碰撞對象（例如<span>OC</span>樹）的碰撞檢測。</p>
<p>可與其他可測量對像一起用於最小距離計算。</p>
<p>可以被接近傳感器檢測到。</p>
<p>可以使用<span>[</span>菜單欄<span>-&gt;</span>添加<span>-&gt;</span>點雲<span>]</span>將點雲添加到場景，並通過點雲屬性進行編輯。</p>
<p><span>CoppeliaSim</span>中可用的點雲計算（即碰撞，距離和接近傳感器計算）也可以通過<span>Coppelia</span>幾何例程作為獨立例程使用。</p>
<p><span> </span>點雲屬性<span>(Point cloud properties)</span></p>
<p>點雲屬性是場景對象屬性對話框的一部分，該對話框位於<span>[</span>菜單欄<span>-&gt;</span>工具<span>-&gt;</span>場景對象屬性<span>]</span>。您還可以通過雙擊場景層次結構中的對像圖標或單擊其工具欄按鈕來打開對話框：</p>
<p><span> <img alt="" height="37" src="/images/雲1.jpg" width="38"/></span></p>
<p><span>[</span>場景對象屬性工具欄按鈕<span>]</span></p>
<p>在場景對象屬性對話框中，單擊“點雲”按鈕以顯示<span>OC</span>樹對話框（“點雲”按鈕僅在最後選擇的是點雲時出現）。該對話框顯示最後選擇的點雲的設置和參數：</p>
<p><img alt="" height="413" src="/images/雲2.jpg" width="380"/></p>
<p><span>[</span>點雲對話框<span>]</span></p>
<p>不要使用<span>OC</span>樹計算。結構：默認情況下，點雲使用類似於<span>OC</span>樹的計算結構進行有效的點操作。此結構可能會減慢插入點和刪除點的速度。如果啟用此項目，則點插入將更加有效，但是點雲將不再可碰撞，不可測量或不可檢測，並且某些其他操作也可能會受到限制。您始終可以在以後的階段或通過<span>sim.setPointCloudOptions</span>切換此項目。</p>
<p>最高體素大小：將包含點的<span>OC</span>樹體素的最大大小。大小越小，此點雲所基於的<span>OC</span>樹數據結構將使用的內存就越大。</p>
<p>最高點數<span>/</span>體素：單個<span>OC</span>樹體素可以包含的最大點數。如果需要在此類體素中存儲更多點，它將被拆分為<span>8</span>個子體素，直到滿足約束條件為止。為了有效地進行碰撞檢測，距離計算和接近傳感器檢測，建議在單個體素中存儲大約<span>10-20</span>個點。</p>
<p>插入選定的可見對象：允許基於選定的可見對象插入點。僅考慮虛擬對象，形狀，超頻樹和點雲。選擇要插入的所有對象，然後最後選擇目標點雲對象。形狀將事先轉換為具有指定構建分辨率的臨時<span>OC</span>樹。插入公差項允許通過指定用於確定是否插入點的最小距離公差來避免重複的點。插入公差<span>&gt; 0.0</span>時，點插入將變慢。</p>
<p>減去選定的可見對象：允許基於選定的可見對象減去點。僅考慮虛擬變量，超頻樹和點雲。選擇要減去的所有對象，然後最後選擇目標點雲對象。假人和點雲將使用減法公差值來標識要刪除的點。</p>
<p>清除點雲：從點雲中刪除所有點。</p>
<p>點具有隨機顏色：每個點將具有隨機顏色。</p>
<p>顯示<span>OC</span>樹結構：顯示底層<span>OC</span>樹數據結構，主要用於調試目的。</p>
<p>顏色是自發光的：點將以自發光的顏色顯示。</p>
<p>點顯示比例：包含大量點的點雲可能會減慢渲染速度。通過將比率設置為小於<span>1</span>，將為每個包含點的<span>OC</span>樹體素顯示更少的點數。這僅對顯示<span>/</span>渲染的圖像有影響。</p>
<p>點大小：點的大小，以像素為單位。</p>
<p>調整下一次插入的顏色：允許選擇一種新的顏色，該顏色將用於新的點插入。</p>
<p>外部控制器教程<span>(External controller tutorial)</span></p>
<p>在<span>CoppeliaSim</span>中，有幾種方法可以控制機器人或仿真：</p>
<p>最方便的方法是編寫一個子腳本來處理給定機器人或模型的行為。這是最方便的方法，因為子腳本直接附加到場景對象，它們將與相關的場景對像一起復制，它們不需要使用外部工具進行任何編譯，它們可以在線程或非線程模式下運行，它們可以通過自定義<span>Lua</span>函數或<span>Lua</span>擴展庫進行擴展。使用子腳本的另一個主要優點是：與本節中提到的後<span>3</span>種方法（即使用常規<span>API</span>）一樣，沒有通信延遲，並且子腳本是應用程序主線程的一部分（固有的同步操作）。但是，編寫腳本有幾個缺點：您無法選擇編程語言，不能擁有最快的代碼，並且除了<span>Lua</span>擴展庫之外，無法直接訪問外部函數庫。</p>
<p>可以控制機器人或模擬的另一種方法是編寫插件。插件機制允許使用回調機制，自定義<span>Lua</span>函數註冊，當然還可以訪問外部函數庫。插件通常與子腳本結合使用（例如，插件註冊自定義的<span>Lua</span>函數，當從子腳本中調用時，該<span>Lua</span>函數將回調特定的插件函數）。使用插件的主要優勢還在於，與本節中提到的後<span>3</span>種方法（即使用常規<span>API</span>）一樣，沒有通信延遲，並且插件是應用程序主線程的一部分（固有的同步操作）。插件的缺點是：它們的編程更加複雜，並且也需要使用外部編譯。另請參閱插件教程。</p>
<p>控制機器人或模擬的第三種方法是編寫依賴於遠程<span>API</span>的外部客戶端應用程序。如果您需要從外部應用程序，機器人或另一台計算機運行控制代碼，這是一種非常便捷的方法。這也使您可以使用與運行真實機器人完全相同的代碼來控制仿真或模型（例如虛擬機器人）。遠程<span>API</span>有兩個版本：基於<span>B0</span>的遠程<span>API</span>和舊版遠程<span>API</span>。</p>
<p><span> </span>控制機器人或仿真的第五種方法是通過<span>ROS</span>節點。<span> ROS</span>與遠程<span>API</span>相似，是使多個分佈式進程相互通信的便捷方法。儘管遠程<span>API</span>非常輕巧且快速，但它僅允許與<span>CoppeliaSim</span>通信。另一方面，<span>ROS</span>允許幾乎將任意數量的進程相互連接，並且提供了大量兼容的庫。但是，它比遠程<span>API</span>重並且更複雜。有關詳細信息，請參閱<span>ROS</span>接口。</p>
<p>控制機器人或模擬的第六種方法是通過<span>BlueZero</span>（<span>BØ</span>）節點。與<span>ROS</span>類似，<span>BlueZero</span>是使多個分佈式進程相互通信的一種便捷方法，並且是一種輕量級的跨平台解決方案。有關詳細信息，請參考<span>BlueZero</span>界面。</p>
<p>控制機器人或模擬的第七種方法是編寫一個外部應用程序，該應用程序通過各種方式（例如管道，套接字，串行端口等）與<span>CoppeliaSim</span>插件或<span>CoppeliaSim</span>腳本進行通信。選擇編程語言（可以是任何一種語言）和靈活性是兩個主要優點。同樣，控制代碼也可以在機器人或其他計算機上運行。但是，與使用遠程<span>API</span>的方法相比，這種控制仿真或模型的方法更加乏味。</p>
<p>有<span>8</span>個與本教程相關的場景文件：<span> </span></p>
<p><span>scenes / controlTypeExamples /</span>受控<span>ViaScript</span>：一個機器人是通過非線程子腳本控制的，另一個是通過線程子腳本控制的。</p>
<p><span>scenes / controlTypeExamples /</span>受控<span>ViaPlugin</span>：機器人是通過插件控制的。</p>
<p><span>scenes / controlTypeExamples / controlViaB0RemoteApi</span>：通過基於<span>B0</span>的遠程<span>API</span>來控制機器人。</p>
<p><span>scenes / controlTypeExamples /</span>受控<span>ViaLegacyRemoteApi</span>：通過舊版遠程<span>API</span>控制機器人。</p>
<p><span>scenes / controlTypeExamples / controlViaB0</span>：通過<span>BlueZero</span>界面控制機器人。</p>
<p><span>scenes / controlTypeExamples /</span>受控<span>ViaRos</span>：通過<span>ROS</span>接口控制機器人。</p>
<p><span>scenes / controlTypeExamples / controlViaRos2</span>：通過<span>ROS2</span>接口控制機器人。</p>
<p><span>scenes / controlTypeExamples /</span>受控<span>ViaTcp</span>：通過<span>LuaSocket</span>和<span>TCP</span>控制機器人。</p>
<p><span><img alt="" height="581" src="/images/輸出.jpg" width="752"/><br/></span></p>
<p>在所有<span>8</span>種情況下，都使用子腳本，主要是為了與外界建立鏈接（例如，啟動正確的客戶端應用程序，並將正確的對象句柄傳遞給它）。有兩種其他方法可以控制機器人，模擬或模擬器本身：使用自定義腳本或附加組件。但是，不建議將它們用於控制，而應使用在模擬未運行時處理功能。<span> </span></p>
<p>例如，鏈接到場景控制的<span>ViaB0RemoteApi.ttt</span>中的機器人的子腳本具有以下主要任務：</p>
<p><span> </span>使用某些對象句柄作為參數啟動控制器應用程序（<span>bubbleRobClient_b0RemoteApi</span>）。基於對象<span>B0</span>的遠程<span>API</span>的服務器功能由對象<span>b0RemoteApiServer</span>提供。</p>
<p>作為另一個示例，鏈接到場景控制的<span>ViaRos.ttt</span>中的機器人的子腳本具有以下主要任務：</p>
<p>檢查是否已加載<span>CoppeliaSim</span>的<span>ROS</span>接口</p>
<p>使用某些主題名稱或對象句柄作為參數啟動控制器應用程序（<span>rosBubbleRob</span>）</p>
<p>然而，作為另一個示例，鏈接到場景控制的<span>ViaTcp.ttt</span>中的機器人的子腳本具有以下主要任務：</p>
<p>搜索空閒的套接字連接端口</p>
<p>使用所選的連接端口作為參數啟動控制器應用程序（<span>bubbleRobServer</span>）</p>
<p>本地連接到控制器應用程序</p>
<p>在每次仿真過程中，將傳感器值發送到控制器，並從控制器讀取所需的電機值</p>
<p>在每次模擬過程中，將所需的電機值應用於機器人的關節</p>
<p>運行模擬，然後復制並粘貼機器人：您將看到重複的機器人將直接運行，因為附加的子腳本負責啟動各自外部應用程序的新實例，或調用適當的插件函數。</p>
<p><em><strong>心得</strong></em></p>
<p>CoppeliaSim 裡面有許多功能可以供我們使用，例如裡面的假人可以被用來測量與機器人的距離，可以被偵測器偵測到的，同時具有可以放在路徑上做為輔助的對象……等，在這個電子書裡讓我訝異的是他的API 不是只有Python能用而已，可以用許多程式來寫API，讓我覺得自己所學的還不太足夠應該多加努力。</p>
<h1>Assignment2</h1>
<h2>TOP 0 文章</h2>
<p>主題:<span>協同設計出更好的產品</span></p>
<p><strong><span>今天，數位產品比以往任何時候都更加複雜。創建它們需要多個團隊</span></strong><br/><strong><span>成員，每個成員都有自己的一套技能和專業知識。例如，在Savvy，我們的客戶</span></strong><br/><strong><span>與以下人員緊密合作：產品經理，UX設計人員，視覺設計師，開發人員，內容</span></strong><br/><strong><span>戰略家和成長專家。</span></strong><br/><strong><span>我們使用設計協作來處理這種複雜性。正確完成，設計協作可助力</span></strong><br/><strong><span>每個專家都有共同的心態，流程和工具，共同建立更好的</span></strong><br/><strong><span>產品更快。</span></strong><br/><strong><span>我們編寫了此資源，以幫助其他應用程序創建者採用協作文化和流程。</span></strong><br/><strong><span>繼續學習為什麼設計協同對於創造吸引人的產品很重要，以及</span></strong><br/><strong><span>經驗。我們還將深入探討設計協作心態和文化，工具的要素</span></strong><br/><strong><span>進行有效的設計協作，以及實際工作中的設計協作示例。</span></strong><br/><strong><span>什麼是“設計”協同？</span></strong><br/><strong><span>在進入之前，我們需要在同一頁上了解什麼是設計協同……</span></strong><br/><strong><span>簡單來說，設計協同就是在設計優先的環境中進行協同。</span></strong><br/><strong><span>由於設計的本質，特別是我們在Savvy所做的設計，設計協同趨向於超越人們通常認為的協作。</span></strong><br/><strong><span>通常將協作定義為兩個或兩個以上的人共同完成一項任務</span></strong><br/><strong><span>為了實現共同的目標，設計協作涉及更多。</span></strong><br/><strong><span>設計協同包括更多具有不同技能，艱鉅挑戰和更大規模的人員,具有深遠影響的目標。</span></strong><br/><strong><span>您可能將協同視為兩個人掛在一塊藝術品上。它只需要溝通，團隊合作和四隻手。設計協同是指一組策展人.精心設計訪問者的體驗。他們選擇藝術品，選擇在何處以及如何懸掛藝術品，</span></strong><br/><strong><span>它所居住的房間（以及房間的照明，家具），甚至前面的房間和建築物</span></strong><br/><strong><span>整個。為什麼設計協作很重要</span></strong><br/><strong><span>您可以在沒有協同的情況下設計產品，但是需要一個協同設計過程才能完成</span></strong><br/><strong><span>不錯的產品。這就是設計協作如此重要的原因。</span></strong><br/><strong><span>我們不僅為客戶構建應用程序。精巧構建複雜且多平台的體驗</span></strong><br/><strong><span>內部系統，在某些情況下還包括整個品牌和業務。為此，我們利用專業知識</span></strong><br/><strong><span>跨多個核心學科：戰略，設計，開發和增長。每個項目都涉及</span></strong><br/><strong><span>許多人都有各自的技能和專長。</span></strong><br/><strong><span>設計協作將這些思想融合在一起，將他們各自的專業知識結合在一起</span></strong><br/><strong><span>創建解決方案，以解決共同目標的所有方面。而不是一個人遇到問題</span></strong><br/><strong><span>角度來看，設計協作將這個問題擺在所有專家面前，迫使他們考慮新</span></strong><br/><strong><span>觀點和可能性。</span></strong></p>
<p><strong><span>例如，我們在設計過程的早期就讓我們的開發人員參與進來，以確保我們</span></strong><br/><strong><span>盡快解決技術機會和局限性。這使我們可以有好處並推動我們的技術能力，同時進一步消除了複雜的障礙處理。它還限制了一個人可以在筒倉中工作的數量，從而使工作保持公開狀態,並強調用戶需求和產品目標。</span></strong></p>
<p><strong><span>培養設計協同心態</span></strong><br/><strong><span>在設計過程中建立有效的協同時，正確的思維方式大有幫助。它規定了誰進行協同，如何進行以及達到何種目的的準則。</span></strong></p>
<p><span><strong>合作適合每個人</strong></span><br/><strong><span>設計師有時會認為不是設計師的人沒有資格提供良好的產品</span></strong><br/><strong><span>反之。但是出色的設計不只是視覺效果。它涵蓋了有關產品的所有內容，從</span></strong><br/><strong><span>它的品牌，工程技術及其成長。</span></strong><br/><strong><span>設計協同吸引了許多人，每個人都有自己的觀點和優勢。它給大家一個聲音。這些新鮮的觀點為設計師提供了更多信息。觀點</span></strong><br/><strong><span>使設計師能夠針對其他設計有持久並有影響的選擇做出正確的決定，</span></strong></p>
<p><span><strong>開發和營銷選擇</strong></span><br/><strong><span>與客戶的合作和其他設計師和團隊的合作一樣重要</span></strong><br/><strong><span>成員。在Savvy，我們讓客戶參與產品的整個創作過程。我們</span></strong><br/><strong><span>花些時間來解釋選項，並與客戶進行討論以確保我們了解他們的想法。</span></strong><br/><strong><span>這使我們能夠及早獲得客戶的認可，並從明確的起點和終點開始工作。</span></strong><br/><strong><span>更大的曝光量並不是什麼好事，沒有人知道他們正在與客戶第一次合作.</span></strong><br/><strong><span>客戶合作意味著無需花費高昂成本就能更快地獲得更清晰的產品</span></strong><br/><strong><span>後退和不必要的會議。</span></strong><br/><strong><span>很容易陷入當下而忽略全局。通過更早地參與更多的人</span></strong><br/><strong><span>而且，您正在與隊友建立更緊密的聯繫，並共同承擔責任，</span></strong><br/><strong><span>對產品成功的興趣。您正在創建一個更加開放和透明的流程，因為更緊密聯繫和投入的團隊。</span></strong></p>
<p><span><strong>合作是背景性的</strong></span><br/><strong><span>客戶向我們提出了複雜的挑戰和目標。更不用說，我們持續努力</span></strong><br/><strong><span>與我們的客戶進行長達數月甚至好幾年的交流，並積累了過去的大量知識</span></strong><br/><strong><span>決策，研究和其他有價值的地方。</span></strong><br/><strong><span>通過採用上下文優先的方法，您可以確保每個人都處於最高水平知識。這樣，他們就可以在產品上做出最明智的決定。</span></strong><br/><strong><span>為了做到這一點，我們通過引入所有團隊成員儘早，記錄和記錄會議，建立一些重疊的地方以及過程中的下一個團隊成員就像客戶一樣。</span></strong><br/><strong><span>在個案協同的基礎上，上下文也同樣重要。請遵循以下準則以保持</span></strong><br/><span><strong>協作中的上下文優先：</strong></span><br/><strong><span>在顯示您的工作之前提供上下文。如果您正在工作，則您的工作是否出現在屏幕上</span></strong><br/><strong><span>提供背景信息，您已經失去了聽眾的注意力。</span></strong><br/><strong><span>描述您要解決的問題或要達到的目標。介紹與當前問題相關的工作。解釋您的想法以及為什麼要這麼做這些決定。請具體說明您要回饋的內容。</span></strong></p>
<p><span><strong>合作是開放，誠實和無畏的</strong></span><br/><strong><span>將您的工作（和您自己）放在那裡並不容易。情緒會阻礙提供</span></strong><br/><strong><span>開放和誠實的反饋，尤其是當您擔心會傷害他人的感受時。</span></strong><br/><strong><span>這並不意味著在協同中沒有情感的位置。</span></strong></p>
<p><strong><span>感覺如何在設計中很重要。我們為有情感，</span></strong><br/><strong><span>在決策中使用情感的人。離開談話可能會縮短</span></strong><br/><strong><span>潛在的想法或解決方案。其實，僅圍繞事實和數據進行實際的討論是不會的。</span></strong><br/><strong><span>提供完整圖片。在最壞的情況下，它可能是不相關或提供虛假的敘述。</span></strong><br/><strong><span>在Savvy，我們使我們的團隊對收到反饋“無所畏懼”。這意味著放手</span></strong><br/><strong><span>關於我們為自己創造的東西而被批評的任何焦慮。這也意味著了解我們</span></strong><br/><strong><span>在一起變得更強大，更有機會創造偉大的事物。無所畏懼，我們</span></strong><br/><strong><span>更好地信任並相互授權，以提供誠實和周到的反饋。</span></strong><br/><strong><span>我們的團隊還相信，不要害怕提供反饋。這意味著了解</span></strong><br/><strong><span>需要解決的問題以及客戶的品牌和目標。這也意味著要問很多</span></strong><br/><strong><span>提問以發現相關思想或幫助指導決策。</span></strong><br/><strong><span>嘗試以探索性和指導性的方式提出反饋意見，以建立並改善工作而不是拆散。您的反饋意見應具有建設性。與其說你不喜歡什麼，不如說</span></strong><br/><strong><span>反饋以指出您要幫助解決的問題。在以下方面提供可行的步驟</span></strong><br/><strong><span>改善工作，或者至少改善您的思維背後的理由。而且不要忘記</span></strong><br/><strong><span>表達您喜歡什麼以及為什麼。</span></strong></p>
<p><br/><span><strong>合作不僅僅是新的想法</strong></span><br/><strong><span>開放並接受協作反饋是一回事，解析這些想法是另一回事</span></strong><br/><strong><span>並將它們用作激發自己的催化劑。這是一項發展起來的高級技能</span></strong><br/><strong><span>時間。一種實踐方法是成為更好的聽眾。</span></strong><br/><strong><span>通常，在與他人交談時，我們會更多地考慮接下來要說的內容</span></strong><br/><strong><span>比別人說什麼這會影響反饋過程，尤其是在設計中，因為我們</span></strong><br/><strong><span>在聽到其他意見或解決方案之前，通常都知道我們要說什麼。</span></strong><br/><strong><span>當您選擇先聆聽然後再做出反應時，它可以讓您完全理解反饋</span></strong><br/><strong><span>有人在介紹您，並讓您更深入-他們使用的觀點是什麼</span></strong><br/><strong><span>他們來自哪裡？很有可能這是您在</span></strong><br/><strong><span>創建過程。通過聽取並理解反饋的上下文和推理</span></strong><br/><strong><span>您正在接受，正在向更多的視角，思維方式和體驗方式開放您的設計。然後，您可以針對挑戰，目標和舉例子測試這些新觀點。</span></strong><br/><strong><span>您正在設計用於查看是否更適合用戶。</span></strong><br/><strong><span>當所有協作者都在積極聆聽時，更容易接受反饋。</span></strong><br/><strong><span>最終，提供良好反饋的技能來自學習如何獲得反饋。當我們做一個</span></strong><br/><strong><span>努力成為更好的聽眾，我們也發現自己變得更加謙虛，我們認為，更好的設計師。</span></strong><br/><strong><span>尋找和使用正確的設計協作工具</span></strong><br/><strong><span>正確的工具在增強團隊的設計協作思維方面大有幫助。 在這</span></strong><br/><strong><span>部分，您將了解在協作工具中尋找什麼。 我們還建議我們的工具及自己的經驗。</span></strong></p>
<p><strong><span>選擇合適的工具</span></strong></p>
<p><strong><span>有效的協作工具為協作者消除了所有障礙，使他們能夠快速輕鬆地訪問和</span></strong><br/><strong><span>與工作互動。 這將重點放在提供反饋上。 他們還允許其他人</span></strong><br/><strong><span>在不破壞原始設計的情況下進行協作。</span></strong><br/><strong><span>過去，我們使用依賴於提供基本版本控制的工具，而不是真正的</span></strong><br/><strong><span>協作功能。 例如，設計人員將保存一個Sketch文件並將其上傳到Dropbox。</span></strong><br/><strong><span>然後，另一個團隊成員將下載它，進行處理，然後重新上傳。 沒有簡單的方法</span></strong><br/><strong><span>在文件移交給他人的情況下進行更改。 我們嘗試了與Github類似的方法，</span></strong><br/><strong><span>實踐證明，該工具非常適合管理代碼庫，但在迭代設計工作中卻不那麼重要。</span></strong><br/><strong><span>不用說，這些版本控制流程使我們的協作更加耗時，</span></strong><br/><strong><span>令人困惑，而且非常不合作。</span></strong><br/><strong><span>現在，我們根據協作類型從多種更高級的工具中進行選擇,並且想要實現。</span></strong></p>
<p><strong><span>FIGMA</span></strong></p>
<p><strong><span>這是一個協作優先的共享工作區工具。 Figma非常適合在其中有多個人</span></strong><br/><strong><span>設計文件的相同區域。 您可以觀看隊友設計或在同一個設計上一起即時工作</span></strong><br/><strong><span>。</span></strong></p>
<p><strong><span>好處:</span></strong></p>
<p><strong><span>Figma降低了某人在筒倉中工作的能力。</span></strong><br/><strong><span>無需添加不必要的修飾或創建靜態可交付結果即可實現協作。 所以</span></strong><br/><strong><span>您無需更改工作流程即可展示設計。</span></strong><br/><strong><span>可以輕鬆地在其本機環境中查看並與之交互，並隨意進行調整。</span></strong><br/><strong><span>何時使用：流量文檔，高保真線框，即時協作和行走</span></strong><br/><strong><span>客戶通過一系列屏幕來解釋並獲得有關設計方向的反饋。</span></strong></p>
<p><strong><span>Marvel</span></strong></p>
<p><strong><span>雖然Figma傾向於感覺更自由和靈活，但Marvel允許更標準化的形式</span></strong><br/><strong><span>合作。 這也使我們的客戶可以輕鬆地與我們合作。</span></strong></p>
<p><strong><span>好處：</span></strong><br/><strong><span>Marvel是一個更簡潔，更規範和集中的空間，非常適合與非設計團隊成員合作</span></strong><br/><strong><span>。</span></strong></p>
<p><strong><span>它消除了客戶支付帳戶或深入了解工具的所有需求</span></strong><br/><strong><span>去看工作。</span></strong><br/><strong><span>客戶可以下載屏幕並通過Marvel在設備環境中查看它們的運行情況</span></strong><br/><strong><span>應用程式。</span></strong><br/><strong><span>使用時間：與客戶和開發人員一起呈現更多最終設計工作。 （學習關於</span></strong><br/><strong><span>Marvel與其他原型工具的比較。）</span></strong></p>
<p><strong><span>其他合作工具</span></strong></p>
<p><span><strong>Zeplin是一個有用的傳遞工具，可讓開發人員深入了解設計的細節。</strong></span><br/><span><strong>工作。 （我們在這裡更深入地討論Zeplin。）</strong></span><br/><span><strong>Quip是集思廣益和產品/過程文檔的絕佳平台。 我們用它來記錄</strong></span><br/><span><strong>並組織團隊成員在工作時需要了解的所有背景和知識</strong></span><br/><span><strong>一個專案。 對於集思廣益而不是視覺關注的新想法也很有用。</strong></span><br/><span><strong>請注意，還有許多其他工具可以為協作增加類似的好處，</strong></span><br/><span><strong>上面列出的。 該列表代表了在我們日常工作中對我們有效的工具</strong></span><br/><span><strong>協作，並不表示所有選項都可能對您的團隊有效.</strong></span></p>
<p><strong><span>精明的設計合作過程在實踐中</span></strong></p>
<p><strong><span>現在，讓我們採用上面概述的最佳實踐和工具，並展示它們如何組合在一起。</span></strong><br/><strong><span>現實生活中的情況。 我們將使用Press Play應用程序中的實時繪圖體驗來演示</span></strong><br/><strong><span>設計協作的重要性。 這項經驗涉及到跨學科的團隊成員數量，包括視覺設計師，UX設計人員，開發人員，產品經理，當然還有客戶。</span></strong></p>
<p><strong><span>處境與挑戰</span></strong></p>
<p><span><strong>Press Play是一個抽獎活動應用程序，可保存每日，每周和每月的圖紙。 用戶獲得門票</strong></span><br/><span><strong>觀看廣告，然後選擇五個表情符號輸入繪圖。 然後根據</strong></span><br/><span><strong>他們的選擇如何與圖形的隨機選擇表情符號匹配。 這個特殊的任務有</strong></span><br/><span><strong>我們為正在等待現場繪畫結果的用戶創造了一個有趣而激動人心的現場體驗。</strong></span><br/><span><strong>對於我們來說，為這種體驗創建類似遊戲的動畫非常重要。 我們特別想要</strong></span><br/><span><strong>在用戶去看他們的屏幕時在屏幕上喚起一種嬉戲和期待感</strong></span><br/><span><strong>所選表情符號與抽獎活動附圖中的表情符號匹配。</strong></span><br/><span><strong>就是說，我們需要注意動畫所需的複雜程度及其影響</strong></span><br/><span><strong>在整個產品的時間表和成本上。 我們的目標是將保真度提高到</strong></span><br/><span><strong>合理的時間，而不會顯著影響項目的預算。</strong></span></p>
<p><strong><span>合作過程</span></strong></p>
<p><strong><span>第一階段：線框和集思廣益</span></strong><br/><strong><span>首先，精明的用戶體驗設計師創建了Press Play的整體用戶體驗和線框，確定了</span></strong><br/><strong><span>需要屏幕和每個屏幕的時間安排。 她還提出了一個粗略的概念（如圖</span></strong></p>
<p><br/><strong><span>右圖）用於實時繪圖動畫，根據客戶的需求和項目的已建立UX。</span></strong><br/><strong><span>她向產品經理和視覺設計師展示了線框和粗糙的動畫設計師。 然後，這三個人都與客戶會面，因此每個人都可以直接聽到反饋。</span></strong></p>
<p><span><strong>第二階段：研究與背景</strong></span></p>
<p><span><strong>精明的視覺設計師負責創建實際的實時繪圖動畫</strong></span><br/><span><strong>新鮮的眼睛，並且對Press Play產品沒有太多的先驗知識。為了起床，他</strong></span><br/><span><strong>與UX設計人員和產品經理進行了深入的交談。他還致力於其他研究</strong></span><br/><span><strong>有時間了解整體產品目標，挑戰並熟悉工作</strong></span><br/><span><strong>至今。如前所述，他是線框演示的一部分，並為客戶反饋。</strong></span><br/><span><strong>在這種情況下，他進行了一些與手頭任務直接相關的其他研究。</strong></span><br/><span><strong>通過這樣做，他確保自己了解現場繪畫體驗的要求，目標和挑戰。他查看了具有類似經驗和保真度的其他應用，並參考了動畫，以了解最終動畫到底需要顯示什麼（在這種情況下，表情符號和用戶的表情符號選擇）。</strong></span></p>
<p><span><strong>在過於束縛解決方案之前，他遇到了一個精明的人</strong></span><br/><span><strong>iOS開發人員了解技術限制和注意事項。</strong></span><br/><span><strong>然後，我們的視覺設計師和UX設計師集思廣益，對視覺效果至關重要。他們</strong></span><br/><span><strong>同意需要為用戶建立緩慢的提示以建立懸念/期望</strong></span></p>
<p><strong><span>階段3：循環和反饋</span></strong><br/><span><strong>當我們的視覺設計師沿多個不同方向工作時，他選擇了UX設計師</strong></span><br/><span><strong>聊聊他在Figma中的進度和設計。通過討論工作，他們激發了更多</strong></span><br/><span><strong>想法和迭代，同時確保它們符合客戶期望。還有更多</strong></span><br/><span><strong>他手下有很多可靠的選擇，他再次與iOS開發人員會面，以確保一切都在</strong></span><br/><span><strong>從技術角度出發。</strong></span></p>
<p><strong><span>階段4：客戶的反饋和發展</span></strong><br/><span><strong>當我們找到更多，更最終的體驗版本時，視覺設計師走了</strong></span><br/><span><strong>通過他們與客戶一起使用Figma。 Press Play產品經理和UX設計師</strong></span><br/><span><strong>還提供了反饋和指導。</strong></span><br/><span><strong>一旦他們都了解了引起顧客興趣的東西，視覺設計師便開始最大限度地發揮作用。</strong></span><br/><span><strong>視覺效果並使它們為開發做好準備。他繼續與iOS開發人員合作，</strong></span><br/><span><strong>在技術層面上充分利用該概念。</strong></span><br/><span><strong>最終結果</strong></span><br/><span><strong>Press Play的實時繪圖動畫是工作中設計協作的一個範例。</strong></span><br/><span><strong>一些跨學科專家一起解決更大的設計和開發挑戰</strong></span><br/><span><strong>意思是。沒有設計協作，我們將找不到理想的交集</strong></span><br/><span><strong>用戶體驗，視覺和技術。</strong></span><br/><span><strong>當客戶在他的應用程序中看到動畫生動時，他稱其為“開創性的”。</strong></span><br/><span><strong>而且，這種Press Play體驗的研究，合作和創造對我們有幫助</strong></span><br/><span><strong>發現產品用戶旅程中的空白。最初，現場繪畫的目的是為了娛樂</strong></span><br/><span><strong>向用戶顯示結果的方式。在設計過程中，我們意識到，如果用戶不觀看實時繪圖，他們就會迷失方向，無法體驗終結該圖紙的用戶旅程。</strong></span><br/><span><strong>基於這一發現，我們決定在其他兩個地方也改進該應用程序。我們添加了一個</strong></span><br/><span><strong>獲勝者範圍的結果/實時繪圖元素，以及用戶的輸贏歷史記錄部分</strong></span><br/><span><strong>應用程序的細節部分。最後，需要用戶體驗,來設計協同使我們得以實現這一些未實現的目標。</strong></span></p>
<p><span><strong>結論說明</strong></span></p>
<p><span><strong>設計協作需要解決建造中伴隨的複雜，關鍵問題</strong></span><br/><span><strong>很棒的產品和經驗。 通過利用多個團隊成員的專業知識</strong></span><br/><span><strong>跨學科的設計協作可確保團隊從各個角度應對挑戰</strong></span><br/><span><strong>並尋求更好的解決方案。 借助正確的思維方式，工具和流程，進行設計協作</strong></span><br/><span><strong>使團隊能夠通過創造性思維和迭代來更深入。</strong></span><br/><span><strong>我們希望本指南為您提供良好的基礎，以便您可以構建自己的有效設計</strong></span><br/><span><strong>協作過程。 您可以在Savvy博客上了解有關設計和產品策略的更多信息，</strong></span><br/><span><strong>並隨時在Savvy Apps網站上與我們聯繫以尋求幫助。</strong></span></p>
<h3>心得</h3>
<p><span><strong>這篇文章看完裡面有句實用的話"</strong><em><span style="color: #ff0000;">設計協作將這些思想融合在一起，將他們各自的專業知識結合在一起</span></em><em><span style="color: #ff0000;">創建解決方案，以解決共同目標的所有方面。而不是一個人遇到問題</span></em><em><span style="color: #ff0000;">角度來看，設計協作將這個問題擺在所有專家面前，迫使他們考慮新</span></em><br/><em><span style="color: #ff0000;">觀點和可能性。</span></em><strong>"我們或許來自不同的縣市，並擁有不同的特長，而協同設計可以無視縣市並將所擁有的特長加以融合，設計出出乎意料的產品，只需要我們勇於交談並會使用工具，我們就可以成為一個好的設計師。</strong></span></p><h2>webots tutorial</h2>
<h3>翻譯</h3>
<p><em><strong><span style="color: #000000;">Programming Fundamentals</span></strong></em></p>
<p><em><strong><span style="color: #000000;">編程基礎</span></strong></em></p>
<p>This chapter introduces the basic concepts of programming with Webots. Webots controllers can be written in C/C++, Java, Python or<em>MATLAB</em><sup>TM</sup>.<span> </span></p>
<p>本章介紹使用<span>Webots</span>進行編程的基本概念。<span> Webots</span>控制器可以用<span>C / C ++</span>，<span>Java</span>，<span>Python</span>或<em>MATLAB</em><sup>TM</sup>編寫。 </p>
<p><span>Besides their syntactic differences all these languages share the same low-level implementation.</span></p>
<p><span> </span>除了語法上的差異外，所有這些語言都共享相同的低階實現。</p>
<p><span> </span><span>As long as the sequence of function/method calls does not vary, every programming language will yield exactly the same simulation results.</span></p>
<p>只要函數<span>/</span>方法的調用順序不變，每種編程語言都會產生完全相同的仿真結果。</p>
<p>Hence, the concepts explained here with C examples also apply to C++, Java, Python and MATLAB.</p>
<p>因此，此處用<span>C</span>示例說明的概念也適用於<span>C ++</span>，<span>Java</span>，<span>Python</span>和<span>MATLAB</span>。</p>
<p><span>Controller Programming</span></p>
<p>控制器編程</p>
<p><span>Hello World Example</span></p>
<p><span>The tradition in computer science is to start with a "Hello World!" example. So here is a "Hello World!" example for a Webots controller:</span></p>
<p>你好世界範例</p>
<p>計算機科學的傳統始於“<span> Hello World</span>！”。 例。 這就是“<span> Hello World</span>！”<span> Webots</span>控制器的範例：</p>
<p><img alt="" height="410" src="/images/1.jpg" width="1058"/></p>
<p>This code repeatedly prints "Hello World!" to the standard output stream which is redirected to Webots console. The standard output and error streams are automatically redirected to Webots console for all Webots supported languages.</p>
<p>此代碼反复打印“ Hello World！”。 到標準輸出流，該輸出將重定向到Webots控制台。 對於所有Webots支持的語言，標準輸出和錯誤流將自動重定向到Webots控制台。</p>
<p>Webots C API (Application Programming Interface) is provided by regular C header files. These header files must be included using statements like #include &lt;webots/xyz.h&gt; where xyz represents the name of a Webots node in lowercase.</p>
<div class="tlid-input input">
<div class="source-wrap">
<div class="input-full-height-wrapper tlid-input-full-height-wrapper">
<div class="source-input">
<div class="source-footer-wrap source-or-target-footer">
<div class="source-footer">
<div class="speech-wrap source-or-target-footer-button left-positioned">
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" id="gt-speech" role="button" tabindex="0"><span class="jfk-button-img"></span></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="tlid-results-container results-container">
<div class="tlid-result result-dict-wrapper">
<div class="result tlid-copy-target">
<div class="text-wrap tlid-copy-target">
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span title="">Webots C API（應用程序編程接口）由常規C頭文件提供。</span> <span class="" title="">這些頭文件必須使用#include &lt;webots / xyz.h&gt;之類的語句包括在內，其中xyz表示小寫的Webots節點的名稱。</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">Like with any regular C code it is also possible to include the standard C headers, e.g. #include &lt;stdio.h&gt;. A call to the initialization wb_robot_init function is required before any other C API function call. </span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">像任何常規C代碼一樣，也可以包括標準C標頭，例如 #include &lt;stdio.h&gt;。 在調用任何其他C API函數之前，需要先調用初始化wb_robot_init函數。</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">This function initializes the communication between the controller and Webots. The wb_robot_cleanup function does the opposite: it closes the communication between the controller and Webots to terminate the controller smoothly. Note that the wb_robot_init and wb_robot_cleanup functions exist only in the C API, they do not have any equivalent in the other supported programming languages.</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">該功能初始化控制器和Webot之間的通信。 wb_robot_cleanup函數的作用與此相反：它關閉了控制器和Webot之間的通信，以平滑地終止控制器。 請注意，wb_robot_init和wb_robot_cleanup函數僅存在於C API中，在其他受支持的編程語言中沒有任何等效功能。</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">Usually the highest level control code is placed inside a for or a while loop. Within that loop there is a call to the wb_robot_step function. This function synchronizes the controller's data with the simulator. The wb_robot_step function needs to be present in every controller and it must be called at regular intervals, therefore it is usually placed in the main loop as in the above example.</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">通常，最高級別的控制代碼位於for或while循環內。 在該循環中，調用了wb_robot_step函數。 該功能使控制器的數據與模擬器同步。 wb_robot_step函數必須存在於每個控制器中，並且必須以規則的時間間隔調用，因此，如上例所示，通常將其放置在主循環中。</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">The value 32 specifies the duration of the control steps, i.e., the wb_robot_step function shall compute 32 milliseconds of simulation and then return. This duration specifies an amount of simulated time, not real (wall clock) time, so it may actually take 1 millisecond or one minute of real time, depending on the complexity of the simulated world.</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">值32指定控制步驟的持續時間，即wb_robot_step函數應計算32毫秒的仿真，然後返回。 此持續時間指定的是模擬時間量，而不是實際（牆上時鐘）時間，因此實際時間可能需要1毫秒或1分鐘，這取決於模擬世界的複雜性。</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span>Note that in this "Hello World!" example, the exit condition of the </span><code>while</code><span><span> </span>loop is the return value of the<span> </span></span><code>wb_robot_step</code><span><span> </span>function. This function will indeed return<span> </span></span><code>-1</code><span><span> </span>when Webots terminates the controller (see<span> </span></span><a class="dynamicAnchor" href="https://cyberbotics.com/doc/guide/controller-programming#controller-termination">Controller Termination</a><span>). Therefore, in this example, the control loop will run as long as the simulation runs. When the loop exists, no further communication with Webots is possible and the only option is to confirm to Webots to close the communication by calling the<span> </span></span><code>wb_robot_cleanup</code><span><span> </span>function.</span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0">
<div class="tlid-input input">
<div class="source-wrap">
<div class="input-full-height-wrapper tlid-input-full-height-wrapper">
<div class="source-input">
<div class="source-footer-wrap source-or-target-footer">
<div class="source-footer">
<div class="speech-wrap source-or-target-footer-button left-positioned">
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" id="gt-speech" role="button" tabindex="0"><span class="jfk-button-img"></span></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="tlid-results-container results-container">
<div class="tlid-result result-dict-wrapper">
<div class="result tlid-copy-target">
<div class="result-header">
<div aria-label="收藏翻譯" class="starbutton jfk-button-flat jfk-button unstarred" data-tooltip="收藏翻譯" data-tooltip-align="t,c" role="button" tabindex="0">
<div class="jfk-button-img"></div>
</div>
</div>
<div class="text-wrap tlid-copy-target">
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span title="">請注意，在此“ Hello World！”中</span> <span class="" title="">例如，while循環的退出條件是wb_robot_step函數的返回值。</span> <span title="">當Webots終止控制器時，此函數的確會返回-1（請參閱控制器終止）。</span> <span class="" title="">因此，在此示例中，控制循環將在仿真運行期間一直運行。</span> <span class="" title="">當存在循環時，無法與Webots進行進一步的通信，並且唯一的選擇是通過調用wb_robot_cleanup函數來向Webots確認關閉通信。</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">Reading Sensors</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">讀數傳感器</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">Now that we have seen how to print a message to the console, we shall see how to read the sensors of a robot. The next example does continuously update and print the value returned by a DistanceSensor:</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">現在，我們已經了解瞭如何將消息打印到控制台，我們將看到如何讀取機器人的傳感器。 下一個示例確實不斷更新並打印由DistanceSensor返回的值：</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><img alt="" height="640" src="/images/2.jpg" width="1056"/></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span>As you can notice, prior to using a device, it is necessary to get the corresponding device tag (</span><code>WbDeviceTag</code><span>); this is done using the<span> </span></span><code>wb_robot_get_device</code><span><span> </span>function. The<span> </span></span><code>WbDeviceTag</code><span><span> </span>is an opaque type that is used to identify a device in the controller code. Note that the string passed to this function,<span> </span></span><em>"my_distance_sensor"</em><span><span> </span>in this example, refers to a device name specified in the robot description (".wbt" or ".proto" file). If the robot has no device with the specified name, this function returns 0.</span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span>如您所見，在使用設備之前，有必要獲取相應的設備標籤（WbDeviceTag）。 這是使用wb_robot_get_device函數完成的。 WbDeviceTag是不透明的類型，用於在控制器代碼中標識設備。 請注意，在此示例中，傳遞給此函數的字符串“ my_distance_sensor”是指機械手描述中指定的設備名稱（“ .wbt”或“ .proto”文件）。 如果機器人沒有指定名稱的設備，則此函數返回0。</span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span>Each sensor must be enabled before it can be used. If a sensor is not enabled it returns undefined values. Enabling a sensor is achieved by using the corresponding <code>wb_*_enable</code><span><span> </span>function, where the star (</span><code>*</code><span>) stands for the sensor type. Every<span> </span></span><code>wb_*_enable</code><span><span> </span>function allows to specify an update delay in milliseconds. The update delay specifies the desired interval between two updates of the sensor's data.</span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span>必須先啟用每個傳感器，然後才能使用它。 如果未啟用傳感器，它將返回未定義的值。 通過使用相應的wb _ * _ enable函數來啟用傳感器，其中星號（*）代表傳感器類型。 每個wb _ * _ enable函數均允許指定更新延遲（以毫秒為單位）。 更新延遲指定兩次傳感器數據更新之間的期望間隔。</span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span>In the usual case, the update delay is chosen to be similar to the control step (<code>TIME_STEP</code><span>) and hence the sensor will be updated at every<span> </span></span><code>wb_robot_step</code><span><span> </span>function call. If, for example, the update delay is chosen to be twice the control step then the sensor data will be updated every two<span> </span></span><code>wb_robot_step</code><span><span> </span>function calls: this can be used to simulate a slow device. Note that a larger update delay can also speed up the simulation, especially for CPU intensive devices like the<span> </span></span><a href="https://cyberbotics.com/doc/reference/camera">Camera</a><span>.</span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span><span></span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span><span>在通常情況下，更新延遲被選擇為與控制步驟（TIME_STEP）相似，因此傳感器將在每次wb_robot_step函數調用時進行更新。 例如，如果將更新延遲選擇為控制步驟的兩倍，則每兩個wb_robot_step函數調用將更新一次傳感器數據：這可用於模擬慢速設備。 請注意，較大的更新延遲也可以加快仿真速度，尤其是對於像相機這樣佔用大量CPU資源的設備而言。</span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span><span></span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span><span>On the contrary, it would be pointless to choose an update delay smaller than the control step, because it will not be possible for the controller to process the device's data at a higher frequency than that imposed by the control step. It is possible to disable a device at any time using the corresponding <code>wb_*_disable</code><span><span> </span>function. This may increase the simulation speed.</span></span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span><span><span></span></span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span><span><span>相反，選擇小於控制步驟的更新延遲將毫無意義，因為控制器將不可能以比控制步驟所施加的頻率更高的頻率來處理設備的數據。 使用對應的wb _ * _ disable函數可以隨時禁用設備。 這可以提高仿真速度。</span></span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span><span><span></span></span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0">
<p>The sensor value is updated during the call to the<span> </span><code>wb_robot_step</code><span> </span>function. The call to the<span> </span><code>wb_distance_sensor_get_value</code><span> </span>function retrieves the latest value.</p>
<p>Note that some device return vector values instead of scalar values, for example these functions:</p>
<p>在調用wb_robot_step函數期間，將更新傳感器值。 調用wb_distance_sensor_get_value函數可檢索最新值。</p>
<p>請注意，某些設備返回矢量值而不是標量值，例如，以下函數：</p>
<p><img alt="" height="86" src="/images/3.jpg" width="498"/></p>
<p><span>Each function returns a pointer to three double values. The pointer is the address of an array allocated by the function internally. These arrays should never be explicitly deleted by the controller code. They will be automatically deleted when necessary. The array contains exactly three double values. Hence accessing the array beyond index 2 is illegal and may crash the controller. Finally, note that the array elements should not be modified, for this reason the pointer is declared as </span><em>const</em><span>. Here are correct examples of code using these functions:</span></p>
<p><span></span></p>
<p><span>每個函數都返回一個指向三個double值的指針。 指針是函數在內部分配的數組的地址。 這些數組絕不能由控制器代碼顯式刪除。 它們將在必要時自動刪除。 該數組恰好包含三個double值。 因此，訪問超出索引2的數組是非法的，並且可能使控制器崩潰。 最後，請注意，不應修改數組元素，因此，指針被聲明為const。 這是使用這些功能的正確代碼示例：</span></p>
<p><span><img alt="" height="500" src="/images/4.jpg" width="1056"/></span></p>
<p><span>And here are incorrect examples:</span></p>
<p><span>這是不正確的範例：</span></p>
<p><span><img alt="" height="218" src="/images/5.jpg" width="1056"/></span></p>
Using Actuators</div>
<div class="result-shield-container tlid-copy-target" tabindex="0">使用執行器</div>
<div class="result-shield-container tlid-copy-target" tabindex="0"></div>
<div class="result-shield-container tlid-copy-target" tabindex="0">
<p>The example below shows how to make a rotational motor oscillate with a 2 Hz sine signal.</p>
<p>Just like sensors, each Webots actuator must be identified by a<span> </span><code>WbDeviceTag</code><span> </span>returned by the<span> </span><code>wb_robot_get_device</code><span> </span>function. However, unlike sensors, actuators don't need to be expressly enabled; they actually don't have<span> </span><code>wb_*_enable</code><span> </span>functions.</p>
<p>以下示例顯示瞭如何使旋轉電機以2 Hz正弦信號振盪。</p>
<p>就像傳感器一樣，每個Webots執行器都必須由wb_robot_get_device函數返回的WbDeviceTag進行標識。 但是，與傳感器不同的是，無需明確啟用執行器。 他們實際上沒有wb _ * _ enable函數。</p>
<p><span>To control a motion, it is generally useful to decompose that motion in discrete steps that correspond to the control step. As before, an infinite loop is used here: at each iteration a new target position is computed according to a sine equation. The </span><code>wb_motor_set_position</code><span><span> </span>function stores a new position request for the corresponding rotational motor. Note that the<span> </span></span><code>wb_motor_set_position</code><span><span> </span>function stores the new position, but it does not immediately actuate the motor. The effective actuation starts on the next line, in the call to the<span> </span></span><code>wb_robot_step</code><span><span> </span>function.</span></p>
<p><span>為了控制運動，通常以與控制步驟相對應的離散步驟分解該運動。 如前所述，這裡使用了無限循環：在每次迭代中，根據正弦方程計算新的目標位置。 wb_motor_set_position函數存儲相應旋轉電機的新位置請求。 請注意，wb_motor_set_position函數存儲新位置，但不會立即啟動電動機。 有效的致動從對wb_robot_step函數的調用的下一行開始。</span></p>
<p><span>The <code>wb_robot_step</code><span><span> </span>function sends the actuation command to the<span> </span></span><a href="https://cyberbotics.com/doc/reference/rotationalmotor">RotationalMotor</a><span><span> </span>but it does not wait for the<span> </span></span><a href="https://cyberbotics.com/doc/reference/rotationalmotor">RotationalMotor</a><span><span> </span>to complete the motion (i.e. reach the specified target position); it just simulates the motor's motion for the specified number of milliseconds.</span></span></p>
<p><span><span>wb_robot_step函數將致動命令發送到RotationalMotor，但不等待RotationalMotor完成運動（即到達指定的目標位置）； 它只是在指定的毫秒數內模擬電動機的運動。</span></span></p>
<p><span><span><img alt="" height="721" src="/images/6.jpg" width="1054"/></span></span></p>
<p><span><span>When the <code>wb_robot_step</code><span><span> </span>function returns, the motor has moved by a certain (linear or rotational) amount which depends on the target position, the duration of the control step (specified with the<span> </span></span><code>wb_robot_step</code><span><span> </span>function argument), the velocity, acceleration, force, and other parameters specified in the ".wbt" description of the<span> </span></span><code>Motor</code><span>.<span> </span></span></span></span></p>
<p><span><span><span>當wb_robot_step函數返回時，電機已移動了一定量（線性或旋轉），具體取決於目標位置，控制步驟的持續時間（由wb_robot_step函數參數指定），速度，加速度，力等 電動機的“ .wbt”描述中指定的參數。</span></span></span></p>
<p><span><span><span>For example, if a very small control step or a low motor velocity is specified, the motor will not have moved much when the <code>wb_robot_step</code><span><span> </span>function returns. In this case several control steps are required for the<span> </span></span><a href="https://cyberbotics.com/doc/reference/rotationalmotor">RotationalMotor</a><span><span> </span>to reach the target position. If a longer duration or a higher velocity is specified, then the motor may have fully completed the motion when the<span> </span></span><code>wb_robot_step</code><span><span> </span>function returns.</span></span></span></span></p>
<p><span><span><span><span>例如，如果指定了非常小的控制步長或較低的電動機速度，則當wb_robot_step函數返回時，電動機將不會移動太多。 在這種情況下，RotationalMotor需要幾個控制步驟才能達到目標位置。 如果指定了更長的持續時間或更高的速度，則當wb_robot_step函數返回時，電動機可能已完全完成運動。</span></span></span></span></p>
<p><span><span><span><span>Note that the <code>wb_motor_set_position</code><span><span> </span>function only specifies the<span> </span></span><em>desired</em><span><span> </span>target position. Just like with real robots, it is possible (in physics-based simulations only), that the<span> </span></span><a href="https://cyberbotics.com/doc/reference/rotationalmotor">RotationalMotor</a><span><span> </span>is not able to reach this position, because it is blocked by obstacles or because the motor's torque (</span><code>maxForce</code><span>) is insufficient to oppose gravity, etc.</span></span></span></span></span></p>
<p><span><span><span><span><span>請注意，wb_motor_set_position函數僅指定所需的目標位置。 就像真正的機器人一樣，RotationalMotor有可能（僅在基於物理的模擬中）無法到達此位置，原因是它被障礙物阻擋，或者因為電動機的扭矩（maxForce）不足以抵抗重力等。 </span></span></span></span></span></p>
<p><span><span><span><span><span>If you want to control the motion of several <a href="https://cyberbotics.com/doc/reference/rotationalmotor">RotationalMotors</a><span><span> </span>simultaneously, then you need to specify the desired position for each<span> </span></span><a href="https://cyberbotics.com/doc/reference/rotationalmotor">RotationalMotor</a><span><span> </span>separately, using the<span> </span></span><code>wb_motor_set_position</code><span><span> </span>function. Then you need to call the<span> </span></span><code>wb_robot_step</code><span><span> </span>function once to actuate all the<span> </span></span><a href="https://cyberbotics.com/doc/reference/rotationalmotor">RotationalMotors</a><span><span> </span>simultaneously.</span></span></span></span></span></span></p>
<p><span><span><span><span><span><span>如果要同時控制多個RotationalMotor的運動，則需要使用wb_motor_set_position函數分別為每個RotationalMotor指定所需的位置。 然後，您需要調用wb_robot_step函數一次以同時啟動所有RotationalMotor。</span></span></span></span></span></span></p>
<p><span><span><span><span><span><span>The "step" and "wb_robot_step" Functions</span></span></span></span></span></span></p>
<p><span><span><span><span><span><span>“步驟”和“ wb機器人步驟”功能</span></span></span></span></span></span></p>
<p>Webots uses two different time steps:</p>
<ul>
<li>The simulation step (specified in the Scene Tree:<span> </span><code>WorldInfo.basicTimeStep</code>)</li>
<li>The control step (specified as an argument of the<span> </span><code>wb_robot_step</code><span> </span>function for each robot)</li>
</ul>
<p>Webots使用兩個不同的時間步驟：</p>
<p>模擬步驟（在“場景樹”中指定：WorldInfo.basicTimeStep）<br/>控制步驟（指定為每個機器人的wb_robot_step函數的參數）</p>
<p><span>The simulation step is the value specified in </span><code>WorldInfo.basicTimeStep</code><span><span> </span>(in milliseconds). It indicates the duration of one step of simulation, i.e. the time interval between two computations of the position, speed, collisions, etc. of every simulated object. If the simulation uses physics (vs. kinematics), then the simulation step also specifies the interval between two computations of the forces and torques that need to be applied to the simulated rigid bodies.</span></p>
<p><span>模擬步驟是WorldInfo.basicTimeStep中指定的值（以毫秒為單位）。 它指示了一個模擬步驟的持續時間，即每個模擬對象的位置，速度，碰撞等兩次計算之間的時間間隔。 如果模擬使用物理學（相對於運動學），則模擬步驟還指定需要對模擬剛體施加力和扭矩的兩次計算之間的間隔。</span></p>
<p><span>The control step is the duration of an iteration of the control loop. It corresponds to the parameter passed to the <code>wb_robot_step</code><span><span> </span>function. The<span> </span></span><code>wb_robot_step</code><span><span> </span>function advances the controller time of the specified duration. It also synchronizes the sensors and actuators data with the simulator according to the controller time.</span></span></p>
<p><span><span>控制步驟是控制循環迭代的持續時間。 它對應於傳遞給wb_robot_step函數的參數。 wb_robot_step函數可將指定時間的控制器時間提前。 它還根據控制器時間將傳感器和執行器的數據與模擬器同步。</span></span></p>
<p><span><span>Every controller needs to call the <code>wb_robot_step</code><span><span> </span>function at regular intervals. If a controller does not call the<span> </span></span><code>wb_robot_step</code><span><span> </span>function, then the sensors and actuators won't be updated and the simulator will block (in synchronous mode only). Because it needs to be called regularly, the<span> </span></span><code>wb_robot_step</code><span><span> </span>function call is usually placed in the main loop of the controller.</span></span></span></p>
<p><span><span><span>每個控制器都需要定期調用wb_robot_step函數。 如果控制器未調用wb_robot_step函數，則不會更新傳感器和執行器，並且模擬器將阻塞（僅在同步模式下）。 由於需要定期調用，因此wb_robot_step函數調用通常位於控制器的主循環中。</span></span></span></p>
<p><span><span><span>The execution of a simulation step is an atomic operation: it cannot be interrupted. Hence a sensor measurement or a motor actuation can only take place between two simulation steps. For that reason the control step specified with each <code>wb_robot_step</code><span><span> </span>function calls must be a multiple of the simulation step. So, for example, if the simulation step is 16 ms, then the control step argument passed to the<span> </span></span><code>wb_robot_step</code><span><span> </span>function can be 16, 32, 64, 128, etc.</span></span></span></span></p>
<p><span><span><span><span>模擬步驟的執行是一項原子操作：不能中斷。 因此，傳感器測量或電機驅動只能在兩個模擬步驟之間進行。 因此，每個wb_robot_step函數調用指定的控制步驟必須是模擬步驟的倍數。 因此，例如，如果模擬步驟為16 ms，則傳遞給wb_robot_step函數的控制步驟參數可以為16、32、64、128等。</span></span></span></span></p>
<p><span><span><span><span>If the simulation is run in step-by-step mode, i.e., by clicking on the <strong>Step</strong><span><span> </span>button (see<span> </span></span><a class="dynamicLoad" href="https://cyberbotics.com/doc/guide/the-user-interface">The User Interface</a><span><span> </span>section), then a single step having the simulation step duration is executed. The following<span> </span></span><a class="dynamicAnchor" href="https://cyberbotics.com/doc/guide/controller-programming#synchronization-of-simulation-and-controller-steps">figure</a><span><span> </span>depicts in details the synchronization between the simulation status, the controller status and the step clicks.</span></span></span></span></span></p>
<p><span><span><span><span><span>如果仿真以逐步模式運行，即通過單擊“步進”按鈕（請參見“用戶界面”部分），則將執行具有仿真步長的單個步驟。 下圖詳細描述了仿真狀態，控制器狀態和步驟咔嗒聲之間的同步。</span></span></span></span></span></p>
<p><span><span><span><span><span><img alt="" height="400" src="/images/7.png" width="275"/></span></span></span></span></span></p>
<p><span><span><span><span><span>At every step, all the commands before the <code>wb_robot_step</code><span><span> </span>function call statements are executed first and the simulation stops in the middle of the execution of the<span> </span></span><code>wb_robot_step</code><span><span> </span>function. Webots API functions are executed but they are applied to the simulation world only when calling the<span> </span></span><code>wb_robot_step</code><span><span> </span>function, that is when the controller process communicates with Webots process. When the simulation stops, the new simulation status has already been computed, the simulation time has been updated and the new sensors values are ready. Note that the first step includes the initialization too. So all the statements before the second<span> </span></span><code>wb_robot_step</code><span><span> </span>function call are executed.</span></span></span></span></span></span></p>
<p><span><span><span><span><span><span>在每個步驟中，首先執行wb_robot_step函數調用語句之前的所有命令，並且模擬在wb_robot_step函數執行的中間停止。 Webots API函數已執行，但僅在調用wb_robot_step函數時（即，控制器進程與Webots進程進行通信時），它們才被應用到仿真世界。 模擬停止時，已經計算出新的模擬狀態，更新了模擬時間，並且準備了新的傳感器值。 請注意，第一步也包括初始化。 因此，第二個wb_robot_step函數調用之前的所有語句都將執行。</span></span></span></span></span></span></p>
<p><span><span><span><span><span><span>Using Sensors and Actuators Together</span></span></span></span></span></span></p>
<p><span><span><span><span><span><span>一起使用傳感器和執行器</span></span></span></span></span></span></p>
<p><span><span><span><span><span><span>Webots and each robot controller are executed in separate processes. For example, if a simulation involves two robots, there will be three processes in total: one for Webots and two for the two robots. Each controller process exchanges sensors and actuators data with the Webots process during the <code>wb_robot_step</code><span><span> </span>function calls. So for example, the<span> </span></span><code>wb_motor_set_position</code><span><span> </span>function does not immediately send the data to Webots. Instead it stores the data locally and the data is effectively sent when the<span> </span></span><code>wb_robot_step</code><span><span> </span>function is called.</span></span></span></span></span></span></span></p>
<div class="tlid-results-container results-container">
<div class="tlid-result result-dict-wrapper">
<div class="result tlid-copy-target">
<div class="text-wrap tlid-copy-target">
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span title="">Webot和每個機器人控制器在單獨的過程中執行。</span> <span class="" title="">例如，如果一個模擬涉及兩個機器人，則總共將有三個過程：一個用於Webot，兩個用於兩個機器人。</span> <span class="" title="">在wb_robot_step函數調用期間，每個控制器進程都與Webots進程交換傳感器和執行器數據。</span> <span class="" title="">因此，例如，wb_motor_set_position函數不會立即將數據發送到Webots。</span> <span class="" title="">相反，它在本地存儲數據，並且在調用wb_robot_step函數時有效地發送了數據。</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span>For that reason the following code snippet is a bad example. Clearly, the value specified with the first call to the </span><code>wb_motor_set_position</code><span><span> </span>function will be overwritten by the second call:</span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span>因此，以下代碼段是一個不好的示例。 顯然，第一次調用wb_motor_set_position函數指定的值將被第二次調用覆蓋：</span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><img alt="" height="134" src="/images/8.jpg" width="900"/></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span>Similarly this code does not make much sense either:</span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span>同樣，此代碼也沒有太大意義：</span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><img alt="" height="215" src="/images/9.jpg" width="690"/></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span>Since there was no call to the <code>wb_robot_step</code><span><span> </span>function between the two sensor readings, the values returned by the sensor cannot have changed in the meantime. A working version would look like this:</span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span>由於在兩個傳感器讀數之間沒有調用wb_robot_step函數，因此在此期間傳感器返回的值不能更改。 工作版本如下所示：</span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span><img alt="" height="281" src="/images/10.jpg" width="638"/></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0">
<p>However, the generally recommended approach is to have a single<span> </span><code>wb_robot_step</code><span> </span>function call in the main control loop, and to use it to update all the sensors and actuators simultaneously, like this:</p>
<pre>但是，通常建議的方法是在主控制循環中只有一個wb_robot_step函數調用，並使用它同時更新所有傳感器和執行器，如下所示：<br/><br/><img alt="" height="161" src="/images/11.jpg" width="555"/></pre>
<p><span>Note that it is important to call the </span><code>wb_robot_step</code><span><span> </span>function at the beginning of the loop, in order to make sure that the sensors already have valid values prior to entering the<span> </span></span><code>readSensors</code><span><span> </span>function. Otherwise the sensors will have undefined values during the first iteration of the loop, hence, the following is not a good example:</span></p>
<p><span>請注意，在循環開始時調用wb_robot_step函數很重要，以確保在進入readSensors函數之前傳感器已經具有有效值。 否則，在循環的第一次迭代中，傳感器將具有不確定的值，因此，以下示例不是一個好例子：</span></p>
<p><span><img alt="" height="165" src="/images/12.jpg" width="983"/></span></p>
<p><span>Here is a complete example of using sensors and actuators together. The robot used here is using differential steering. It uses two proximity sensors (<a href="https://cyberbotics.com/doc/reference/distancesensor">DistanceSensor</a><span>) to detect obstacles.</span></span></p>
<p><span><span>這是一起使用傳感器和執行器的完整示例。 這裡使用的機器人正在使用差速轉向。 它使用兩個接近傳感器（DistanceSensor）來檢測障礙物。</span></span></p>
<p><span><span><img alt="" height="755" src="/images/13.jpg" width="703"/></span></span></p>
<p><span><span>Using Controller Arguments</span></span></p>
<p><span><span>使用控制器參數</span></span></p>
<p><span><span>In the ".wbt" file, it is possible to specify arguments that are passed to a controller when it starts. They are specified in the controllerArgs field of the Robot node, and they are passed as parameters of the main function. For example, this can be used to specify parameters that vary for each robot's controller.<br/>For example if we have:</span></span></p>
<p><span><span>在“ .wbt”文件中，可以指定啟動時傳遞給控制器的參數。 它們在Robot節點的controllerArgs字段中指定，並作為主函數的參數傳遞。 例如，可用於指定隨每個機器人控制器而變化的參數。<br/>例如，如果我們有：</span></span></p>
<p><span><span><img alt="" height="125" src="/images/14.jpg" width="543"/></span></span></p>
<p><span><span>And if the controller's name is <em>"demo"</em><span>, then this sample controller code:</span></span></span></p>
<p><span><span><span>如果控制器的名稱為“ demo”，則此示例控制器代碼為：</span></span></span></p>
<p><span><span><span><img alt="" height="280" src="/images/15.jpg" width="433"/></span></span></span></p>
<p><span><span><span>This will print:</span></span></span></p>
<p><span><span><span>這將打印：</span></span></span></p>
<p><span><span><span><img alt="" height="108" src="/images/16.jpg" width="261"/></span></span></span></p>
<p><span><span><span>Controller Termination</span></span></span></p>
<p><span><span><span>控制器終端</span></span></span></p>
<p><span><span><span>Usually a controller process runs in an endless loop: it is terminated (killed) when Webots quits, the simulation is reset, the world is reloaded, a new simulation is loaded, or the controller name is changed in the Webots scene tree. The controller cannot prevent its own termination but it can be notified shortly before this happens. </span></span></span></p>
<p><span><span><span>通常，控制器進程會無休止地運行：當Webots退出，模擬被重置，世界被重新加載，新的模擬被加載或者Webots場景樹中的控制器名稱被更改時，它終止（被殺死）。 控制器無法阻止其自身終止，但是可以在發生這種情況之前立即通知控制器。</span></span></span></p>
<p><span><span><span>The <code>wb_robot_step</code><span><span> </span>function returns -1 when the controller process is going to be terminated by Webots. Then the controller has 1 second (real time) to save important data, close files, etc. before it is effectively killed by Webots. Here is an example that shows how to save data before the upcoming termination:</span></span></span></span></p>
<p><span><span><span><span>當控制器進程將由Webots終止時，wb_robot_step函數返回-1。 然後，控制器將有1秒（實時）的時間來保存重要數據，關閉文件等，直到Webots有效地將其殺死。 這是顯示如何在即將終止之前保存數據的示例：</span></span></span></span></p>
<p><span><span><span><span><img alt="" height="481" src="/images/17.jpg" width="511"/></span></span></span></span></p>
<p><span><span><span><span>In some cases, it is up to the controller to make the decision of terminating the simulation. For example in the case of search and optimization algorithms: the search may terminate when a solution is found or after a fixed number of iterations (or generations).</span></span></span></span></p>
<p><span><span><span><span>在某些情況下，取決於控制器來決定終止仿真。 例如，在搜索和優化算法的情況下：當找到解決方案時或在固定數量的迭代（或生成）之後，搜索可能會終止。</span></span></span></span></p>
<p><span><span><span><span>In this case the controller should just save the experiment results and quit by returning from the <code>main</code><span><span> </span>function or by calling the<span> </span></span><code>exit</code><span><span> </span>function. This will terminate the controller process and freeze the simulation at the current simulation step. The physics simulation and every robot involved in the simulation will stop.</span></span></span></span></span></p>
<p><span><span><span><span><span>在這種情況下，控制器應只保存實驗結果並通過從主函數返回或調用退出函數退出。 這將終止控制器過程並凍結當前模擬步驟的模擬。 物理模擬以及模擬中涉及的每個機器人都將停止。</span></span></span></span></span></p>
<p><span><span><span><span><span><img alt="" height="121" src="/images/18.jpg" width="341"/></span></span></span></span></span></p>
<p><span><span><span><span><span>If only one robot controller needs to terminate but the simulation should continue with the other robots, then the terminating robot should call the <code>wb_robot_cleanup</code><span><span> </span>function right before quitting:</span></span></span></span></span></span></p>
<p><span><span><span><span><span><span>如果僅一個機器人控制器需要終止，而仿真應與其他機器人繼續進行，則終止的機器人應在退出之前立即調用wb_robot_cleanup函數：</span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><img alt="" height="145" src="/images/19.jpg" width="376"/></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span>Note that the exit status as well as the value returned by the <code>main</code><span><span> </span>function are ignored by Webots.</span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span>請注意，Webots會忽略退出狀態以及主函數返回的值。</span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span>Shared Libraries</span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span>共享庫</span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span>Creating shared libraries can be very useful to share code between controllers and/or plugins. There are several ways to do so, but we recommend to place them into a subdirectory of the <code>libraries</code><span><span> </span>directory of your project. Indeed the environment variables of the controllers are modified to include these paths into your [[DY]LD_LIBRARY_]PATH environment variable (depending on the OS). Moreover the main Makefile ("</span><a href="https://github.com/cyberbotics/webots/tree/master/resources/Makefile.include" target="_blank">WEBOTS_HOME/resources/Makefile.include</a><span>") used to compile Webots controllers is able to create shared libraries and to link easily with the Controller libraries, ODE or the Qt framework.</span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span>創建共享庫對於在控制器和/或插件之間共享代碼非常有用。 有幾種方法可以這樣做，但是我們建議將它們放在項目庫目錄的子目錄中。 實際上，已修改控制器的環境變量，以將這些路徑包括到您的[[DY] LD_LIBRARY_] PATH環境變量中（取決於OS）。 此外，用於編譯Webots控制器的主要Makefile（“ WEBOTS_HOME / resources / Makefile.include”）能夠創建共享庫，並可以輕鬆地與Controller庫，ODE或Qt框架鏈接。</span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span>A good example of this is the Qt utility library located there: "WEBOTS_HOME/resources/projects/libraries/qt_utils".<br/>If for some reason shared libraries cannot be in the libraries directory, the WEBOTS_LIBRARY_PATH environment variable will be very helpful. The paths it contains will be added at the beginning of the library search path([[DY]LD_LIBRARY_]PATH) when starting the controller.</span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span>一個很好的例子是位於此處的Qt實用程序庫：“ WEBOTS_HOME / resources / projects / libraries / qt_utils”。<br/>如果由於某種原因共享庫不能位於庫目錄中，則WEBOTS_LIBRARY_PATH環境變量將非常有幫助。 啟動控制器時，它包含的路徑將添加到庫搜索路徑（[[DY] LD_LIBRARY_] PATH）的開頭。</span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span>Environment Variables</span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span>環境變量</span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span>For some projects it will be necessary to define or change variables defined in your environment. They can be changed in the settings of the computer but it may last only for the current session or create conflict with other applications or projects. Webots offers an elegant solution to this. A configuration file named "runtime.ini" can be added to the controller directory. Any environment variable defined in this file will be loaded to the environment each time the controller starts.</span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span>對於某些項目，有必要定義或更改在您的環境中定義的變量。 可以在計算機的設置中更改它們，但可能僅持續當前會話，或者與其他應用程序或項目產生衝突。 Webots為此提供了一個優雅的解決方案。 可以將名為“ runtime.ini”的配置文件添加到控制器目錄。 每次控制器啟動時，此文件中定義的任何環境變量都會加載到環境中。</span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span>This configuration file uses the standard INI template that is really simple and easy to write and read. It contains pairs of key and value that can be inside [sections]. Comments can be written on a line after using a semicolon ';' character.<br/>Environment variables in this file can contain references to other environment variables using this syntax : $(MY_VARIABLE_NAME). They will be automatically replaced by the actual value already existing in the environment. The Webots "runtime.ini" supports 7 sections:</span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span>此配置文件使用標準的INI模板，該模板非常簡單，易於讀寫。 它包含可以在[sections]內部的鍵和值對。 使用分號“;”後可以在一行上寫註釋。 字符。<br/>該文件中的環境變量可以使用以下語法包含對其他環境變量的引用：$（MY_VARIABLE_NAME）。 它們將自動替換為環境中已經存在的實際值。 Webots的“ runtime.ini”支持7個部分：</span></span></span></span></span></span></span></span></p>
<ul>
<li>
<p><code>[environment variables with paths]</code></p>
<p>This section should only contain environment variables with either relative or absolute paths. Paths must be separated using the colon symbol ':' and directory components must be separated using the slash symbol '/'. Variables declared in this section will be added on every platform. On Windows, colons will be replaced by semicolon and slash will be replaced by backslash according to the Windows syntax.</p>
</li>
<li>
<p><code>[environment variables]</code></p>
<p>Environment variables defined in this section will also be added to the environment on every platform but they will be written directly with no syntax change. It's a good location for variables that don't contain any path.</p>
</li>
<li>
<p><code>[environment variables for Windows]</code></p>
<p>Variables defined in this section will only be added to the environment if the controller is ran on the Windows platform. If you want to declare paths in this section, the value should be written between double-quotes symbols ".</p>
</li>
<li>
<p><code>[environment variables for macOS]</code></p>
<p>Variables defined here will only be added on macOS and ignored on other platforms.</p>
</li>
<li>
<p><code>[environment variables for Linux]</code></p>
<p>Variables defined here will be added on all Linux platforms but not on Mac nor Windows.</p>
</li>
<li>
<p><code>[environment variables for Linux 32]</code></p>
<p>These variables will be added only if the Linux platform is 32 bit.</p>
</li>
<li>
<p><code>[environment variables for Linux 64]</code></p>
<p>These variables will be added only if the Linux platform is 64 bit.</p>
</li>
</ul>
<p>[帶路徑的環境變量]</p>
<p>此部分應僅包含具有相對路徑或絕對路徑的環境變量。路徑必須使用冒號'：'分隔，目錄組件必須使用斜杠'/'分隔。本節中聲明的變量將在每個平台上添加。在Windows上，根據Windows語法，冒號將由分號替換，斜杠將由反斜杠替換。</p>
<p>[環境變量]</p>
<p>本節中定義的環境變量也將添加到每個平台的環境中，但是它們將直接編寫而無需更改語法。對於不包含任何路徑的變量，這是一個很好的位置。</p>
<p>[Windows環境變量]</p>
<p>僅當在Windows平台上運行控制器時，才會將本節中定義的變量添加到環境中。如果要在本節中聲明路徑，則應在雙引號符號“之間寫入值。</p>
<p>[macOS的環境變量]</p>
<p>此處定義的變量將僅在macOS上添加，而在其他平台上被忽略。</p>
<p>[Linux的環境變量]</p>
<p>此處定義的變量將在所有Linux平台上添加，但不會在Mac和Windows上添加。</p>
<p>[Linux 32的環境變量]</p>
<p>僅當Linux平台為32位時，才添加這些變量。</p>
<p>[Linux 64的環境變量]</p>
<p>僅當Linux平台是64位時，才添加這些變量。</p>
<p><span>Here is an example of a typical runtime.ini file.</span></p>
<p><span>這是典型的runtime.ini文件的示例。</span></p>
<p><span><img alt="" height="321" src="/images/20.jpg" width="553"/></span></p>
<p><span>Languages Settings</span></p>
<p>語言設定</p>
<p><span>The "runtime.ini" file may also contain language specific sections, named </span><code>[java]</code><span>,<span> </span></span><code>[python]</code><span><span> </span>and<span> </span></span><code>[matlab]</code><span>. Each of this section may include two keys, namely<span> </span></span><code>COMMAND</code><span><span> </span>and<span> </span></span><code>OPTIONS</code><span>. The<span> </span></span><code>COMMAND</code><span><span> </span>key allows you to define a specific version of the language interpreter whereas the<span> </span></span><code>OPTIONS</code><span><span> </span>key allows you to access specific options that will be passed immediately to the language interpreter. For example:</span></p>
<p><span>“ runtime.ini”文件還可能包含特定於語言的部分，名為[java]，[python]和[matlab]。 每個部分都可以包括兩個鍵，即COMMAND和OPTIONS。 COMMAND鍵允許您定義語言解釋器的特定版本，而OPTIONS鍵則允許您訪問將立即傳遞給語言解釋器的特定選項。 例如：</span></p>
<p><span><img alt="" height="124" src="/images/21.jpg" width="413"/></span></p>
<p><span>In the example above, the resulting command issued by Webots will be: <code>/opt/local/bin/python2.7 -m package.name.given my_controller.py</code><span><span> </span>possibly followed by the value of the<span> </span></span><code>controllerArgs</code><span><span> </span>field of the corresponding<span> </span></span><a href="https://cyberbotics.com/doc/reference/robot">Robot</a><span><span> </span>node.</span></span></p>
<p><span><span>在上面的示例中，Webots發出的結果命令將是：/opt/local/bin/python2.7 -m package.name.given my_controller.py，其後可能是相應Robot節點的controllerArgs字段的值。</span></span></p>
<p><span><span><img alt="" height="196" src="/images/22.jpg" width="419"/></span></span></p>
<p><span><span><img alt="" height="123" src="/images/23.jpg" width="703"/></span></span></p>
<p><span><span></span></span></p>
<div class="tlid-input input">
<div class="source-wrap">
<div class="input-full-height-wrapper tlid-input-full-height-wrapper">
<div class="source-input">
<div class="source-footer-wrap source-or-target-footer">
<div class="source-footer">
<div class="speech-wrap source-or-target-footer-button left-positioned">
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" id="gt-speech" role="button" tabindex="0"><em><strong><span class="jfk-button-img" style="color: #000000;">Python Example</span></strong></em></div>
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" role="button" tabindex="0"><em><strong><span class="jfk-button-img" style="color: #000000;">Python範例</span></strong></em></div>
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" role="button" tabindex="0"><em><strong><span class="jfk-button-img" style="color: #000000;"></span></strong></em></div>
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" role="button" tabindex="0"><em><strong><span class="jfk-button-img" style="color: #000000;"><img alt="" height="664" src="/images/24.jpg" width="1055"/></span></strong></em></div>
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" role="button" tabindex="0"><em><strong><span class="jfk-button-img" style="color: #000000;"></span></strong></em></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div><h1>實作紀錄</h1><h2>第二週</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/fvJZQbrG8Z4" width="560"></iframe></p>
<h2>第三週</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/CRgCsgsqe6Y" width="560"></iframe></p>
<h2>第五週</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/JhLrbChe39o" width="560"></iframe></p>
<h2>第六週</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/5tw_-ZenPcI" width="560"></iframe></p>
<h2>第七週</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/wpWHEi3GWk0" width="560"></iframe></p>
<p>OBS</p>
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" role="button" tabindex="0"><span class="jfk-button-img" style="color: #000000;"></span></div>
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" role="button" tabindex="0"><span class="jfk-button-img" style="color: #000000;">使用obs在youtube直播</span></div>
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" role="button" tabindex="0"><span class="jfk-button-img" style="color: #000000;"> </span></div>
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" role="button" tabindex="0"><span style="color: #000000;"><em><strong><span class="jfk-button-img">特別感謝40723136彭少鍚幫助測試</span></strong></em></span></div>
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" role="button" tabindex="0"><span class="jfk-button-img" style="color: #000000;"> </span></div>
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" role="button" tabindex="0"><span class="jfk-button-img" style="color: #000000;"><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/3x6I3apRF74" width="560"></iframe></span></div>
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" role="button" tabindex="0">
<h2>第九週</h2>
<p>期中報告</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/FSWc_FGePlg" width="560"></iframe></p>
<h2>第十週</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/vjY0mEinnVI" width="560"></iframe></p>
<h2>第十三週</h2>
<p>首先到 <a href="http://mde.tw/cd2020pj1/content/Ubuntu.html">http://mde.tw/cd2020pj1/content/Ubuntu.html</a> 使用 gm 帳號 下載Ubuntu20_cd2020pj1.ova  <span>Ubuntu2020_w12.ova  這兩個檔案</span></p>
<p><img alt="" height="1080" src="/images/chrome_2020-06-07_20-34-01.png" width="1920"/></p>
<p>到 <a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a> 載virtualbox</p>
<p><img alt="" height="1080" src="/images/2020-06-07_20-35-29.png" width="1920"/></p>
<p>開啟<span>virtualbox 使用導入 Ubuntu20_cd2020pj1.ova  <span>Ubuntu2020_w12.ova  這兩個檔案  (附註: 這兩個檔案放在桌面)</span></span></p>
<p><span><img alt="" height="1033" src="/images/2020-06-07_21-37-06.png" width="994"/></span></p>
<p><span>之後 匯入硬碟磁碟機作為 VDI(I)  一定要勾</span></p>
<p><span><img alt="" height="1030" src="/images/VirtualBox_2020-06-07_21-37-22.png" width="960"/></span></p>
<p><span></span>進去裡面  密碼為帳號  kmol2020  (附註: Nom Lock記得開啟 進去預設為沒開)</p>
<p><span><img alt="" height="1080" src="/images/2020-06-07_20-40-18.jpg" width="1920"/></span></p>
<p><span>點 Activities －&gt;  LXTerminal</span></p>
<p><span><img alt="" height="1080" src="/images/2020-06-07_20-42-09.png" width="1920"/></span></p>
<p><span>然後使用 ifconfig  查 ip</span></p>
<p><span>IPv4:10.0.2.4</span></p>
<p><span>IPv6:fd17:625c:f037:2:a00:27ff:fef6:9b8a</span></p>
<p><span><img alt="" height="1030" src="/images/VirtualBoxVM_2020-06-07_20-46-29.png" width="1920"/></span></p>
<p><span>回到virtualbox 進入 喜好設定－&gt;網路－&gt; 新增NetNeteork－&gt; 網路 CIDR(C)  10.0.2.0/24</span></p>
<p><span><img alt="" height="1030" src="/images/VirtualBox_2020-06-07_20-36-46.png" width="960"/></span></p>
<p><span>IPv4 設定如下 (IPv6要在學校設定)</span></p>
<p><span><img alt="" height="1030" src="/images/VirtualBox_2020-06-07_20-37-42.png" width="960"/></span></p>
<p><span>輸入 leo  開啟 cd2020pj1.leo</span></p>
<p><span><img alt="" height="626" src="/images/2020-06-07_20-53-18.png" width="897"/></span></p>
<p><span></span>可以看到 需要 oauth_gm.txt</p>
<p><span><img alt="" height="538" src="/images/2020-06-07_20-54-44.png" width="795"/></span></p>
<p><span>用SciTE 輸入 123 123 測試用的  名稱 oauth_gm.txt</span></p>
<p><span><img alt="" height="779" src="/images/2020-06-07_20-54-55.png" width="662"/></span></p>
<p>放在 tmp 裡面</p>
<p><span><img alt="" height="520" src="/images/2020-06-07_20-55-08.png" width="638"/></span></p>
<p>cd tmp/cd2020pj1</p>
<p>python3 wsgi.py 可得知要改ip</p>
<p><span><img alt="" height="474" src="/images/2020-06-07_21-00-08.png" width="653"/></span></p>
<p><span>點開cd2020pj1裡的wsgi.py   host=10.0.2.4 , port=8443</span></p>
<p><span><img alt="" height="417" src="/images/2020-06-07_22-57-59.png" width="649"/></span></p>
<p><span>重新輸入 python3 wsgi.py</span></p>
<p><span><img alt="" height="178" src="/images/2020-06-07_22-58-17.png" width="737"/></span></p>
<p><span></span>在火狐開  https://10.0.2.4:8443/</p>
<p><img alt="" height="1030" src="/images/VirtualBoxVM_2020-06-07_23-23-53.png" width="1920"/></p>
<p>點進去發現錯誤</p>
<p><img alt="" height="1030" src="/images/VirtualBoxVM_2020-06-07_23-24-07.png" width="1920"/></p>
<p>把之前在 <span>oauth_gm.txt 內容改成之前設好的 API  放進去</span></p>
<p><img alt="" height="129" src="/images/2020-06-07_23-59-29.png" width="651"/></p>
<p>因為個人遇到不知問題，選擇後門登入 https://10.0.2.4:8443/alogin </p>
<p><img alt="" height="1030" src="/images/VirtualBoxVM_2020-06-07_23-44-08.png" width="1920"/></p>
<p>就可以出現下面畫面</p>
<p><img alt="" height="1030" src="/images/VirtualBoxVM_2020-06-07_23-44-23.png" width="1920"/></p>
<p></p><h1>直播紀錄討論</h1>
<h2>w2分配工作</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/JXUKf0cfJcc" width="560"></iframe></p>
<h2>w3</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/QTfPD5bpeKc" width="560"></iframe></p>
<h2>w5</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/ElNea4b1dX8" width="560"></iframe></p>
<p></p>
<h2>w6如何操作OBS</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/B6jt5OAf424" width="560"></iframe></p>
<h2>w7討論線上課程及meet討論</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/96y-KSUWDyE" width="560"></iframe></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/958HX03aAf8" width="560"></iframe></p>
<h2>w9</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/opi_PrsUMW4" width="560"></iframe></p>
<h2>w10</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/HauW6F-ez7w" width="560"></iframe></p>
<h2>w11</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/Y-v5v3glZM4" width="560"></iframe></p>
<h2>w12</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/Fwt_LDqD964" width="560"></iframe></p>
<p></p></div>